<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Carol</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Carol">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Carol">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carol">
  
    <link rel="alternative" href="/atom.xml" title="Carol" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/avatar.png">
  
  <link rel="stylesheet" href="/main.css?v=4.0.0.css">
  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/avatar.png" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">caroltuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Carol&#39;s blog</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a data-idx="0" q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a data-idx="1" q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a data-idx="2" q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://caroltuan.github.io/" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/3908875562?refer_flag=1001030102_&is_all=1" title="weibo"><i class="icon-weibo"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">caroltuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">caroltuan</h1>
			</hgroup>
			
			<p class="header-subtitle">Carol&#39;s blog</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
		        
		        	<li><a href="/archives/">所有文章</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://caroltuan.github.io/" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3908875562?refer_flag=1001030102_&is_all=1" title="weibo"><i class="icon-weibo"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-ajax" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/ajax/">ajax</a>
    </h1>
  

        <a href="/2016/12/20/ajax/" class="archive-article-date">
  	<time datetime="2016-12-20T02:10:29.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Ajax是一个异步刷新的技术。可以现实在页面上的局部刷新。</p>
<p>Ajax技术实现只使用一个xhr对象。</p>
<h5 id="XHR对象的属性，方法和事件"><a href="#XHR对象的属性，方法和事件" class="headerlink" title="XHR对象的属性，方法和事件"></a>XHR对象的属性，方法和事件</h5><h6 id="用open方法创建一个请求"><a href="#用open方法创建一个请求" class="headerlink" title="用open方法创建一个请求"></a>用open方法创建一个请求</h6><p>​    open(method, url, asynchronous)<br>​    method: 请求类型。可以是get或post</p>
<p>​    url: 请求地址。可以使用绝对、相对地址，地址可以附带查询字符串</p>
<p>​    asynchronous: 可选参数，请求同步还是异步。默认为true（异步）</p>
<h6 id="用send方法发送一个请求"><a href="#用send方法发送一个请求" class="headerlink" title="用send方法发送一个请求"></a>用send方法发送一个请求</h6><p>​    send(parameter)<br>     发送无参数请求:send(null)</p>
<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><p>onreadystatechange   每个状态改变时都会触发这个事件处理器，通常会调用一个 JavaScript</p>
<p>readyState    请求的状态，有5个可取值： 0=未初始化, 1=正在加载, 2=已加载, 3=交互中, 4=完成 </p>
<p>responseText   响应内容正文的纯文本形式 </p>
<p>responseXML  使用XML表示服务器的响应，这个对象可以解析为一个 DOM 对象 </p>
<p>status  服务器的 HTTP 状态码（200对应OK，404对应Not Found）</p>
<p>使用ajax实现一个请求</p>
<p>servlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</div><div class="line"><span class="keyword">import</span> net.sf.json.JsonConfig;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.domain.Goods;</div><div class="line"><span class="keyword">import</span> com.domain.Types;</div><div class="line"></div><div class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"GoodsServlet"</span>, urlPatterns = &#123; <span class="string">"/find.do"</span> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">			<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">		<span class="comment">// 获得商品的集合</span></div><div class="line">		List&lt;Goods&gt; goodsList = <span class="keyword">new</span> ArrayList&lt;Goods&gt;();</div><div class="line">		Types types = <span class="keyword">new</span> Types(<span class="number">1</span>, <span class="string">"手机"</span>);</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">1</span>, <span class="string">"小米1"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">2</span>, <span class="string">"小米2"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">3</span>, <span class="string">"小米3"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">4</span>, <span class="string">"小米4"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">5</span>, <span class="string">"小米5"</span>, types));</div><div class="line">		</div><div class="line">		<span class="comment">//把集合转成json数组,将json数组转成json文本</span></div><div class="line">		JsonConfig jsonConfig = <span class="keyword">new</span> JsonConfig();</div><div class="line">		jsonConfig.setExcludes(<span class="keyword">new</span> String[]&#123;<span class="string">"goodsSet"</span>&#125;);</div><div class="line">		JSONArray jsonArray = JSONArray.fromObject(goodsList,jsonConfig);</div><div class="line"></div><div class="line">		response.setContentType(<span class="string">"text/html"</span>);</div><div class="line">		response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line"></div><div class="line">		out.print(jsonArray.toString());</div><div class="line">		</div><div class="line">		out.flush();</div><div class="line">		out.close();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jsp</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv="expires" content="0"&gt;</div><div class="line">&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;</div><div class="line">&lt;meta http-equiv="description" content="This is my page"&gt;</div><div class="line">&lt;!--</div><div class="line">	&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;</div><div class="line">	--&gt;</div><div class="line"></div><div class="line">&lt;script type="text/javascript" src="/ajaxjson/js/jquery-1.11.1.min.js"&gt;&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">$(document).ready(function()&#123;</div><div class="line">	$("#btnquery").click(function()&#123;</div><div class="line">		$.ajax(&#123;</div><div class="line">			type: 'get',</div><div class="line">			dataType: 'json',</div><div class="line">			url: '/ajaxjson/find.do',</div><div class="line">			data: &#123;"time":new Date()&#125;,</div><div class="line">			success: function(data)&#123;</div><div class="line">					var goodsbody = document.getElementById("goodsbody");</div><div class="line">					goodsbody.innerHTML = "";</div><div class="line">					for ( var i = 0; i &lt; data.length; i++) &#123;</div><div class="line">						var goodsTr = goodsbody.insertRow();</div><div class="line">						var goodsNameTd = goodsTr.insertCell();</div><div class="line">						goodsNameTd.innerText = data[i].gid;</div><div class="line">						var goodsPriceTd = goodsTr.insertCell();</div><div class="line">						goodsPriceTd.innerText = data[i].gname;</div><div class="line">						var goodsNumTd = goodsTr.insertCell();</div><div class="line">						goodsNumTd.innerText = data[i].types.tname;</div><div class="line">					&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">	&lt;input type="button" value="查询" id="btnquery"&gt;</div><div class="line">	&lt;table width="80%" cellpadding="0" border="1" cellspacing="0"&gt;</div><div class="line">		&lt;thead&gt;</div><div class="line">			&lt;tr&gt;</div><div class="line">				&lt;th&gt;商品编号&lt;/th&gt;</div><div class="line">				&lt;th&gt;商品名称&lt;/th&gt;</div><div class="line">				&lt;th&gt;商品类型&lt;/th&gt;</div><div class="line">			&lt;/tr&gt;</div><div class="line">		&lt;/thead&gt;</div><div class="line">		&lt;tbody id="goodsbody"&gt;&lt;/tbody&gt;</div><div class="line">	&lt;/table&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ajax/">ajax</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/20/ajax/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-json" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/json/">json</a>
    </h1>
  

        <a href="/2016/12/20/json/" class="archive-article-date">
  	<time datetime="2016-12-20T01:41:43.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSON是一种数据表示的格式，包括json对象和json数组。</p>
<h5 id="json的基本语法格式"><a href="#json的基本语法格式" class="headerlink" title="json的基本语法格式"></a>json的基本语法格式</h5><p>对象： { 属性：值 ， 属性：值 }</p>
<p>数组：[对象，对象，对象]<br>获得一个数组的大小 使用 length属性。</p>
<p>访问一个对象的属性：json对象.属性。。。。可以取值也可赋值。<br>访问一个数组中的元素的方式：json数组[索引]</p>
<p>JSON文本是一个符合JSON语法格式的字符串。因为服务器只能返回文本。</p>
<p>JSON文本转换成JSON对象使用eval函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> json对象 = <span class="built_in">eval</span>(“(“+json文本+”)”);</div></pre></td></tr></table></figure>
<p>在服务器端，在Java类中三个状态之间的转换。</p>
<p>1 json文本<br>2 json对象/数组<br>3 java对象/集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</div><div class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</div><div class="line"><span class="keyword">import</span> net.sf.json.JsonConfig;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.domain.Goods;</div><div class="line"><span class="keyword">import</span> com.domain.Stu;</div><div class="line"><span class="keyword">import</span> com.domain.Types;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONTest</span> </span>&#123;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java对象。</span></div><div class="line">		Stu stu = <span class="keyword">new</span> Stu(<span class="number">1</span>,<span class="string">"peter"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//先将java对象转换成json对象</span></div><div class="line">		JSONObject jsonobj = JSONObject.fromObject(stu);</div><div class="line">		</div><div class="line">		<span class="comment">//将json对象转换成json文本。</span></div><div class="line">		String jsontxt = jsonobj.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsontxt);</div><div class="line">		<span class="comment">//将json文本转换成json对象</span></div><div class="line">		JSONObject jsono = JSONObject.fromObject(jsontxt);</div><div class="line">		<span class="comment">//将json对象转换成java对象</span></div><div class="line">		Stu s = (Stu) (JSONObject.toBean(jsono, Stu.class));</div><div class="line">		</div><div class="line">		System.out.println(s.getName());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java集合。</span></div><div class="line">		Stu stu1 = <span class="keyword">new</span> Stu(<span class="number">1</span>,<span class="string">"peter1"</span>);</div><div class="line">		Stu stu2 = <span class="keyword">new</span> Stu(<span class="number">2</span>,<span class="string">"peter2"</span>);</div><div class="line">		Stu stu3 = <span class="keyword">new</span> Stu(<span class="number">3</span>,<span class="string">"peter3"</span>);</div><div class="line">		List&lt;Stu&gt; stuList = <span class="keyword">new</span> ArrayList&lt;Stu&gt;();</div><div class="line">		stuList.add(stu1);</div><div class="line">		stuList.add(stu2);</div><div class="line">		stuList.add(stu3);</div><div class="line">		</div><div class="line">		<span class="comment">//将java集合转换成json数组</span></div><div class="line">		JSONArray jsonArray = JSONArray.fromObject(stuList);</div><div class="line">		</div><div class="line">		<span class="comment">//将json数组转换成json文本</span></div><div class="line">		String jsonArrayTxt = jsonArray.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsonArrayTxt);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java对象。</span></div><div class="line">		Types types = <span class="keyword">new</span> Types(<span class="number">1</span>, <span class="string">"手机"</span>);</div><div class="line">		Goods goods = <span class="keyword">new</span> Goods(<span class="number">1</span>, <span class="string">"iPhone 7"</span>, types);</div><div class="line">		</div><div class="line">		JSONObject jsonObject = JSONObject.fromObject(goods);</div><div class="line">		</div><div class="line">		String jsonObjectTxt = jsonObject.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsonObjectTxt);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java对象。</span></div><div class="line">		Types types = <span class="keyword">new</span> Types(<span class="number">1</span>, <span class="string">"手机"</span>);</div><div class="line">		Goods goods = <span class="keyword">new</span> Goods(<span class="number">1</span>, <span class="string">"iPhone 7"</span>, types);</div><div class="line">		types.getGoodsSet().add(goods);</div><div class="line">		</div><div class="line">		<span class="comment">//使用jsonConfig对象配置转换。可以设置哪些属性表示，哪些属性不表示,在两个类双向的属性包含对方的时候使用。</span></div><div class="line">		JsonConfig jsonConfig = <span class="keyword">new</span> JsonConfig();</div><div class="line">      <span class="comment">//表示显示时候types里面的goodsset将不会显示，从而不会造成死循环</span></div><div class="line">		jsonConfig.setExcludes(<span class="keyword">new</span> String[]&#123;<span class="string">"goodsSet"</span>&#125;);</div><div class="line">		</div><div class="line">		JSONObject jsonObject = JSONObject.fromObject(goods,jsonConfig);</div><div class="line">		</div><div class="line">		String jsonObjectTxt = jsonObject.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsonObjectTxt);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/json/">json</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/20/json/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-throwable" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/19/throwable/">throwable</a>
    </h1>
  

        <a href="/2016/12/19/throwable/" class="archive-article-date">
  	<time datetime="2016-12-19T06:19:42.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-19</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="\images\throwable.jpg" alt="throwable"></p>
<p>  转：</p>
<p><a href="http://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/6155636</a></p>
<p>Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p> Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p>。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p>
<p> Exception（异常）:是程序本身可以处理的异常。</p>
<p> Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p>
<p>  在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。</p>
<p> 抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p>
<p> 捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
<p> 对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p>
<p>​    由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p>
<p>  对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p>
<p>  对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p>
<p>   能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</p>
<p>​    任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。</p>
<p> 从方法中抛出的任何异常都必须使用throws子句。</p>
<p> 捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p>
<p>  总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>
<h5 id="Java常见异常"><a href="#Java常见异常" class="headerlink" title="Java常见异常"></a>Java常见异常</h5><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p>
<ol>
<li>runtimeException子类:<br> 1、 java.lang.ArrayIndexOutOfBoundsException<br> 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br> 2、java.lang.ArithmeticException<br> 算术条件异常。譬如：整数除零等。<br> 3、java.lang.NullPointerException<br> 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br> 4、java.lang.ClassNotFoundException<br> 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。<br>5、java.lang.NegativeArraySizeException  数组长度为负异常<br>6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常<br>7、java.lang.SecurityException 安全性异常<br>8、java.lang.IllegalArgumentException 非法参数异常<br>2.IOException<br>IOException：操作输入流和输出流时可能出现的异常。<br>EOFException   文件已结束异常<br>FileNotFoundException   文件未找到异常</li>
<li>其他<br>ClassCastException    类型转换异常类<br>ArrayStoreException  数组中包含不兼容的值抛出的异常<br>SQLException   操作数据库异常类<br>NoSuchFieldException   字段未找到异常<br>NoSuchMethodException   方法未找到抛出的异常<br>NumberFormatException    字符串转换为数字抛出的异常<br>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常<br>IllegalAccessException  不允许访问某类异常<br>InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li>
</ol>
<p>抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常。下面它们之间的异同。</p>
<p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常。</p>
<p>throw是语句抛出一个异常。</p>
<p>throws是方法可能抛出异常的声明。</p>
<p><strong>throw与throws的比较</strong></p>
<p>1、throws出现在方法函数头；而throw出现在函数体。<br>2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。<br>3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/throwable/">throwable</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/19/throwable/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-jspservlet" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/18/jspservlet/">jsp servlet（基础整理）</a>
    </h1>
  

        <a href="/2016/12/18/jspservlet/" class="archive-article-date">
  	<time datetime="2016-12-18T15:12:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="JSP-HTML-JAVA"><a href="#JSP-HTML-JAVA" class="headerlink" title="JSP = HTML + JAVA"></a>JSP = HTML + JAVA</h5><p>JSP页面的运行环境—JSP服务器，JSP容器</p>
<p>TOMCAT是一个JSP页面的运行环境的程序。WEB应用服务器。</p>
<p>作用是向浏览器输出。 格式： &lt;%=  表达式内容 %&gt;  注意：表达式的最后没有“;”</p>
<p>脚本 &lt;%  %&gt; 在HTML页面中嵌入JAVA代码的区域。可以访问后台的JAVA类。调用业务方法。</p>
<p>B/S 浏览器/服务器模型。</p>
<p>C/S 客户端/服务器模型。</p>
<p>Client/Server是建立在局域网的基础上的。Browser/Server是建立在广域网的基础上的.。<br>　　1．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的， 不必是专门的网络硬件环境。例如电话上网,，租用设备.，信息管理，有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。<br>　　2．对安全要求不同：C/S 一般面向相对固定的用户群， 对信息安全的控制能力很强， 一般高度机密的信息系统采用C/S 结构适宜，可以通过B/S发布部分可公开信息。B/S 建立在广域网之上, 对安全的控制能力相对弱，面向是不可知的用户群。<br>　　3．对程序架构不同：C/S 程序可以更加注重流程,，可以对权限多层次校验,，对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑,，建立在需要更加优化的基础之上，比C/S有更高的要求。 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统.。SUN 和IBM推的JavaBean 构件技术等，使 B/S更加成熟。<br>　　4．软件重用不同：C/S 程序可以不可避免的整体性考虑，构件的重用性不如在B/S要求下的构件的重用性好。B/S 对的多重结构,要求构件相对独立的功能，能够相对较好的重用。<br>　　5．系统维护不同：系统维护在是软件生存周期中，开销大。重要C/S 程序由于整体性,，必须整体考察， 处理出现的问题以及系统升级。升级难，可能是再做一个全新的系统。B/S程序由构件组成，方便构件个别的更换，实现系统的无缝升级，系统维护开销减到最小，用户从网上自己下载安装就可以实现升级。<br>　　6．处理问题不同：C/S 程序可以处理用户面固定，并且在相同区域,，安全要求高需求，与操作系统相关，应该都是相同的系统。B/S 建立在广域网上，面向不同的用户群，分散地域，这是C/S无法作到的，与操作系统平台关系最小。<br>　　7．用户接口不同：C/S 多是建立的Window平台上，表现方法有限。对程序员普遍要求较高。B/S 建立在浏览器上,，有更加丰富和生动的表现方式与用户交流，并且大部分难度减低，减低开发成本。<br>　　8．信息流不同：C/S 程序一般是典型的中央集权的机械式处理，交互性相对低。B/S 信息流向可变化， B-B、 B-C、 B-G等信息流向的变化，更象交易中心。</p>
<p>B/S 特点集中部署—-所有内容都在服务器-基于请求/响应方式进行浏览器与服务器之间的交互—–两个H。</p>
<p>HTTP：请求与响应的协议，规定标准。<br>HTML：响应的内容就只是HTML。因为IE只认识HTML。</p>
<h5 id="JSP页面隐式对象"><a href="#JSP页面隐式对象" class="headerlink" title="JSP页面隐式对象"></a>JSP页面隐式对象</h5><p>详解戳</p>
<p>[]: <a href="http://blog.csdn.net/sona_shi555/article/details/7797068" target="_blank" rel="external">http://blog.csdn.net/sona_shi555/article/details/7797068</a>    “JSP九大内置对象的作用和用法总结”</p>
<p>对于HTTP中get和post区别</p>
<p>详情有两篇博文</p>
<p><a href="http://blog.csdn.net/yipiankongbai/article/details/24025633" target="_blank" rel="external">http://blog.csdn.net/yipiankongbai/article/details/24025633</a></p>
<p>和<a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="external">http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml</a></p>
<h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>现在开一个Servlet要</p>
<pre><code>1继承HttpServlet

2重写doGet或doPost方法
</code></pre><p>1、doGet()针对get请求方式。</p>
<p>doPost()针对Post请求方式。</p>
<p>2、Servlet接口中没有doGet()和doPost()方法的。只有一个service()方法。</p>
<p>Service()方法是服务方法，用户发送一次请，就调用一次Service（）方法。</p>
<p>3、 在HttpServlet中将Service方法给出的实现，转换成了调用相应的doGet和doPost方法。</p>
<h5 id="转发重定向区别："><a href="#转发重定向区别：" class="headerlink" title="转发重定向区别："></a>转发重定向区别：</h5><p>重定向和转发有一个重要的不同：当使用转发时，JSP容器将使用一个内部的方法来调用目标页面，新的页面继续处理同一个请求，而浏览器将不会知道这个过程。 与之相反，重定向方式的含义是第一个页面通知浏览器发送一个新的页面请求。因为，当你使用重定向时，浏览器中所显示的URL会变成新页面的URL, 而当使用转发时，该URL会保持不变。重定向的速度比转发慢，因为浏览器还得发出一个新的请求。同时，由于重定向方式产生了一个新的请求，所以经过一次重定向后，request内的对象将无法使用。</p>
<p>​          怎么选择是重定向还是转发呢？通常情况下转发更快，而且能保持request内的对象，所以他是第一选择。但是由于在转发之后，浏览器中URL仍然指向开始页面，此时如果重载当前页面，开始页面将会被重新调用。如果你不想看到这样的情况，则选择转发。 </p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp-servlet/">jsp servlet</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/18/jspservlet/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-threadlocal" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/threadlocal/">threadlocal</a>
    </h1>
  

        <a href="/2016/12/14/threadlocal/" class="archive-article-date">
  	<time datetime="2016-12-14T11:00:35.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-14</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> ThreadLocal是解决线程安全问题一个很好的思路，ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本，由于Key值不可重复，每一个“线程对象”对应线程的“变量副本”，而到达了线程安全。</p>
<p>Spring通过各种DAO模板类降低了开发者使用各种数据持久技术的难度。这些模板类都是线程安全的，也就是说，多个DAO可以复用同一个模板实例而不会发生冲突。</p>
<p>我们使用模板类访问底层数据，根据持久化技术的不同，模板类需要绑定数据连接或会话的资源。但这些资源本身是非线程安全的，也就是说它们不能在同一时刻被多个线程共享。</p>
<p>虽然模板类通过资源池获取数据连接或会话，但资源池本身解决的是数据连接或会话的缓存问题，并非数据连接或会话的线程安全问题。</p>
<p>按照传统经验，如果某个对象是非线程安全的，在多线程环境下，对对象的访问必须采用synchronized进行线程同步。但Spring的DAO模板类并未采用线程同步机制，因为线程同步限制了并发访问，会带来很大的性能损失。</p>
<h5 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h5><p>早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p>
<p>ThreadLocal很容易让人望文生义，想当然地认为是一个“本地线程”。其实，ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。</p>
<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。</p>
<p>线程局部变量并不是Java的新发明，很多语言（如IBM IBM XL FORTRAN）在语法层面就提供线程局部变量。在Java中没有提供在语言级支持，而是变相地通过ThreadLocal的类提供支持。</p>
<p>所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。</p>
<p><strong>ThreadLocal的接口方法</strong></p>
<p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p>
<p>· void set(Object value) </p>
<p>设置当前线程的线程局部变量的值。</p>
<p>· public Object get() </p>
<p>该方法返回当前线程所对应的线程局部变量。</p>
<p>· public void remove() </p>
<p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p>
<p>· protected Object initialValue() </p>
<p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
<p>值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</p>
<p>ThreadLocal**是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">SimpleThreadLocal</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadLocal</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Map valueMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object newValue)</span> </span>&#123;</div><div class="line"></div><div class="line">		valueMap.put(Thread.currentThread(), newValue);</div><div class="line">  		①**键为线程对象，值为本线程的变量副本**</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	Thread currentThread = Thread.currentThread();</div><div class="line"></div><div class="line">		Object o = valueMap.get(currentThread);</div><div class="line">  		②**返回本线程对应的变量**</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (o == <span class="keyword">null</span> &amp;&amp; !valueMap.containsKey(currentThread)) &#123;</div><div class="line">      ③**如果在Map中不存在，放到Map**中保存起来。</div><div class="line"></div><div class="line">	o = initialValue();</div><div class="line"></div><div class="line">	valueMap.put(currentThread, o);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> o;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	valueMap.remove(Thread.currentThread());</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这个ThreadLocal实现版本显得比较幼稚，但它和JDK所提供的ThreadLocal类在实现思路上是相近的。</p>
<p>一个具体的实例了解一下ThreadLocal的具体使用方法。</p>
<p> SequenceNumber</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao.basic;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceNumber</span> </span>&#123;</div><div class="line"></div><div class="line">①**通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值**</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal seqNum = <span class="keyword">new</span> ThreadLocal()&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">②**获取下一个序列值**</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	seqNum.set(seqNum.get()+<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> seqNum.get();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">	SequenceNumber sn = <span class="keyword">new</span> SequenceNumber();</div><div class="line"></div><div class="line">	③ <span class="number">3</span>**个线程共享sn，各自产生序列号**</div><div class="line"></div><div class="line">	TestClient t1 = <span class="keyword">new</span> TestClient(sn);</div><div class="line"></div><div class="line">	TestClient t2 = <span class="keyword">new</span> TestClient(sn);</div><div class="line"></div><div class="line">	TestClient t3 = <span class="keyword">new</span> TestClient(sn);</div><div class="line"></div><div class="line">	t1.start();</div><div class="line">	</div><div class="line">	t2.start();</div><div class="line"></div><div class="line">	t3.start();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> SequenceNumber sn;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClient</span><span class="params">(SequenceNumber sn)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.sn = sn;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;④**每个线程打出<span class="number">3</span>个序列值**</div><div class="line"></div><div class="line">System.out.println(<span class="string">"thread["</span>+Thread.currentThread().getName()+</div><div class="line"></div><div class="line"><span class="string">"] sn["</span>+sn.getNextNum()+<span class="string">"]"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个SequenceNumber实例。运行以上代码，在控制台上输出以下的结果：</p>
<p><strong>thread[Thread-2] sn[1]</strong></p>
<p><strong>thread[Thread-0] sn[1]</strong></p>
<p><strong>thread[Thread-1] sn[1]</strong></p>
<p><strong>thread[Thread-2] sn[2]</strong></p>
<p><strong>thread[Thread-0] sn[2]</strong></p>
<p><strong>thread[Thread-1] sn[2]</strong></p>
<p><strong>thread[Thread-2] sn[3]</strong></p>
<p><strong>thread[Thread-0] sn[3]</strong></p>
<p><strong>thread[Thread-1] sn[3]</strong></p>
<p>考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个SequenceNumber实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。</p>
<p>Thread同步机制的比较</p>
<p>ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
<p>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<p>当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal，这将极大地简化你的程序，使程序更加易读、简洁。</p>
<p>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal版本。</p>
<p>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<p>Spring使用ThreadLocal解决线程安全问题</p>
<p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolderTransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</p>
<p>一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程</p>
<p>这样你就可以根据需要，将一些非线程安全的变量以ThreadLocal存放，在同一次请求响应的调用线程中，所有关联的对象引用到的都是同一个变量。</p>
<p>下面的实例能够体现Spring对有状态Bean的改造思路：</p>
<p>代码清单3 TopicDao：非线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDao</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Connection conn;①**一个非线程安全的变量**</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">			Statement stat = conn.createStatement();</div><div class="line">    	  ②**引用非线程安全变量**        </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造：</p>
<p> TopicDao：线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDao</span> </span>&#123;</div><div class="line"></div><div class="line">①**使用ThreadLocal保存Connection变量**</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal connThreadLocal = <span class="keyword">new</span> ThreadLocal();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	②**如果connThreadLocal没有本线程对应的Connection创建一个新的	Connection，**并将其保存到线程本地变量中。</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (connThreadLocal.get() == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">	Connection conn = ConnectionManager.getConnection();</div><div class="line"></div><div class="line">	connThreadLocal.set(conn);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> conn;</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> connThreadLocal.get();③**直接返回线程本地变量**</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	④**从ThreadLocal中获取线程对应的Connection**</div><div class="line"></div><div class="line">	Statement stat = getConnection().createStatement();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不同的线程在使用TopicDao时，先判断connThreadLocal.get()是否是null，如果是null，则说明当前线程还没有对应的Connection对象，这时创建一个Connection对象并添加到本地线程变量中；如果不为null，则说明当前的线程已经拥有了Connection对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的Connection，而不会使用其它线程的Connection。因此，这个TopicDao就可以做到singleton共享了。</p>
<p>当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在DAO只能做到本DAO的多个方法共享Connection时不发生线程安全问题，但无法和其它DAO共用同一个Connection，要做到同一事务多DAO共享同一Connection，必须在一个共同的外部类使用ThreadLocal保存Connection。但这个实例基本上说明了Spring对有状态类线程安全化的解决思路。</p>
<p>小结</p>
<p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/14/threadlocal/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-JDBC" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/JDBC/">JDBC（基础整理）</a>
    </h1>
  

        <a href="/2016/12/11/JDBC/" class="archive-article-date">
  	<time datetime="2016-12-11T07:00:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java Database Connection:java数据库连接技术。</p>
<p>查看详情</p>
<p>四种连接方式（只写两种）：</p>
<p>1 桥连： JDBC-ODBC连接。</p>
<p> 2 直连： 直接通过JDBC驱动连接数据库。</p>
<h5 id="JDBC中的核心接口与类"><a href="#JDBC中的核心接口与类" class="headerlink" title="JDBC中的核心接口与类"></a>JDBC中的核心接口与类</h5><h6 id="三个核心接口"><a href="#三个核心接口" class="headerlink" title="三个核心接口"></a>三个核心接口</h6><p>Connection接口：连接数据库接口。负责与数据库之间的连接。</p>
<p>Statement接口：操作数据库接口，常用的子接口PreparedStatement接口，预处理SQL语句。负责执行CRUD命令。</p>
<p>​   获得Statement对象  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Statement stat = conn.createStatement();</div></pre></td></tr></table></figure>
<p>​ 执行查询的方法：</p>
<pre><code>ResultSet rs = stat.executeQuery(SQL);
</code></pre><p>执行增删改的方法:</p>
<p>​    int i = stat.executeUpdate(SQL);</p>
<p>ResultSet接口：结果集接口。负责接收查询的结果。</p>
<p>结果集对象下移一条时调用方法 next();</p>
<p>​          两个值：BOF , EOF</p>
<p>​        BOF：第一行的前面。rs对象一开始指向的位置就是BOF。</p>
<p>​        EOF：最后一行的后面。rs对象的next方法是下移一行，如果移动之  后指向了EOF返回false，表示没有记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.ResultSet;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//连接数据库的四大参数项</span></div><div class="line">		String username = <span class="string">"scott"</span>;</div><div class="line">		String password = <span class="string">"tiger"</span>;</div><div class="line">		String driver_class=<span class="string">"oracle.jdbc.driver.OracleDriver"</span>;<span class="comment">//驱动类名称</span></div><div class="line">		String url = <span class="string">"jdbc:oracle:thin:@localhost:1521:XE"</span>;<span class="comment">//连接字符串</span></div><div class="line"><span class="comment">//		1、加载JDBC的驱动-连接哪个数据库产品就加载哪个数据库的JDBC驱动</span></div><div class="line">		Class.forName(driver_class);</div><div class="line"><span class="comment">//		2、创建与数据库之间的连接</span></div><div class="line">		Connection conn = DriverManager.getConnection(url, username	, password);</div><div class="line"><span class="comment">//		3、执行CRUD命令</span></div><div class="line">		String sql = <span class="string">"select * from emp"</span>;</div><div class="line">		Statement stat = conn.createStatement();</div><div class="line"><span class="comment">//		4、如果是查询就处理结果集</span></div><div class="line">		ResultSet rs = stat.executeQuery(sql);</div><div class="line">		<span class="comment">//rs是结果集对象，结果集就是一个二维表格。</span></div><div class="line">		<span class="keyword">while</span>(rs.next())&#123;<span class="comment">//下一行。如果返回true说明有记录。</span></div><div class="line">			<span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);</div><div class="line">			String ename = rs.getString(<span class="string">"ename"</span>);</div><div class="line">			Date date = rs.getDate(<span class="string">"hiredate"</span>);</div><div class="line">			System.out.println(empno+<span class="string">":"</span>+ename+<span class="string">":"</span>+date);</div><div class="line">		&#125;</div><div class="line"><span class="comment">//		5、关闭连接，释放资源</span></div><div class="line">		rs.close();</div><div class="line">		stat.close();</div><div class="line">		conn.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对数据库进行增删改操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.ResultSet;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//连接数据库的四大参数项</span></div><div class="line">		String username = <span class="string">"scott"</span>;</div><div class="line">		String password = <span class="string">"tiger"</span>;</div><div class="line">		String driver_class=<span class="string">"oracle.jdbc.driver.OracleDriver"</span>;<span class="comment">//驱动类名称</span></div><div class="line">		String url = <span class="string">"jdbc:oracle:thin:@localhost:1521:XE"</span>;<span class="comment">//连接字符串</span></div><div class="line"><span class="comment">//		1、加载JDBC的驱动-连接哪个数据库产品就加载哪个数据库的JDBC驱动</span></div><div class="line">		Class.forName(driver_class);</div><div class="line"><span class="comment">//		2、创建与数据库之间的连接</span></div><div class="line">		Connection conn = DriverManager.getConnection(url, username	, password);</div><div class="line">		System.out.println(conn);</div><div class="line"><span class="comment">//		3、执行CRUD命令</span></div><div class="line">		String sql = <span class="string">"insert into dept(deptno,dname,loc) values(50 , '总部' ,'北京远洋')"</span>;</div><div class="line">		Statement stat = conn.createStatement();</div><div class="line">		<span class="keyword">int</span> count = stat.executeUpdate(sql);<span class="comment">//增删改都调用这个方法</span></div><div class="line">		<span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"操作成功！"</span>);</div><div class="line">		&#125;</div><div class="line"><span class="comment">//		7.5、关闭连接，释放资源</span></div><div class="line">		stat.close();</div><div class="line">		conn.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PreparedStatement接口：Statement子接口，预处理SQL语句。</p>
<h5 id="创建PreparedStatement接口的实例"><a href="#创建PreparedStatement接口的实例" class="headerlink" title="创建PreparedStatement接口的实例"></a>创建PreparedStatement接口的实例</h5><p>String sql = “insert into dept(deptno,dname,loc) values(?,?,?)”;//可以使用?占位符</p>
<p>PreparedStatementpstat = conn.prepareStatement(sql);</p>
<p>//为占位符赋值</p>
<p>pstat.setInt(1, deptno);</p>
<p>pstat.setString(2, dname);</p>
<p>pstat.setString(3, loc);</p>
<p>执行</p>
<p>pstat.executeUpdate();</p>
<h3 id="数据库连接池技术"><a href="#数据库连接池技术" class="headerlink" title="数据库连接池技术"></a>数据库连接池技术</h3><h6 id="世面上主流有-DBCP-C3P0"><a href="#世面上主流有-DBCP-C3P0" class="headerlink" title="世面上主流有:DBCP , C3P0"></a>世面上主流有:DBCP , C3P0</h6><h5 id="使用DBCP创建数据库连接对象"><a href="#使用DBCP创建数据库连接对象" class="headerlink" title="使用DBCP创建数据库连接对象"></a>使用DBCP创建数据库连接对象</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="\images\DBCP.png" alt="DBCP"></h5><h5 id="设置DBCP连接池参数"><a href="#设置DBCP连接池参数" class="headerlink" title="设置DBCP连接池参数"></a>设置DBCP连接池参数</h5><p> 创建一个资源文件.properteis。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">driverClassName=oracle.jdbc.driver.OracleDriver  url=jdbc:oracle:thin:<span class="meta">@localhost</span>:<span class="number">1521</span>:XE </div><div class="line"></div><div class="line">username=scott</div><div class="line"></div><div class="line">  password=tiger</div><div class="line"></div><div class="line">  maxActive=<span class="number">50</span>--最大活动数量</div><div class="line"></div><div class="line">  maxIdle=<span class="number">20</span> </div><div class="line"></div><div class="line">  --最大空闲数量</div><div class="line"></div><div class="line">  maxWait=<span class="number">60000</span> --最大等待时间，毫秒。</div></pre></td></tr></table></figure>
<p>## </p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDBC/">JDBC</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/JDBC/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-java-API" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/java-API/">java collection接口（基础整理）</a>
    </h1>
  

        <a href="/2016/12/11/java-API/" class="archive-article-date">
  	<time datetime="2016-12-11T02:49:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="集合的整体的框架结构"><a href="#集合的整体的框架结构" class="headerlink" title="集合的整体的框架结构"></a>集合的整体的框架结构</h5><p>转自</p>
<p><a href="http://blog.csdn.net/softwave/article/details/4166598" target="_blank" rel="external">http://blog.csdn.net/softwave/article/details/4166598</a></p>
<p><img src="\images\collection.png" alt="collection"></p>
<p>在整个集合框架中顶层的接口：Collection接口。</p>
<p> 在Collection接口下有两个子接口List 和Set</p>
<p> 在整个集合框架中还有一个接口Map</p>
<p>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap</p>
<p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）<br>　　所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个 Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后 一个构造函数允许用户复制一个Collection。<br>　　如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：<br>　　　　Iterator it = collection.iterator(); // 获得一个迭代子<br>　　　　while(it.hasNext()) {<br>　　　　　　Object obj = it.next(); // 得到下一个元素<br>　　　　}<br>　　由Collection接口派生的两个接口是List和Set。</p>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><strong>List接口</strong></h4><p>　　List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。<br>和下面要提到的Set不同，List允许有相同的元素。<br>　　除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素， 还能向前或向后遍历。<br>　　实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p>
<p><strong>LinkedList类</strong><br>　　LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。<br>　　注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br>　　List list = Collections.synchronizedList(new LinkedList(…));</p>
<p><strong>ArrayList类</strong>　　</p>
<p>​     ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。</p>
<p>size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。</p>
<p>　　每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a> 并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。<br>　　和LinkedList一样，ArrayList也是非同步的（unsynchronized）。</p>
<p><strong>Vector类</strong>　　</p>
<p>​     Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和 ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了 Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。</p>
<p><strong>Stack 类</strong><br>　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口　"></a><strong>Set接口</strong>　</h4><p>　Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。<br>　　很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。<br>　　请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p>
<h5 id="hashset类"><a href="#hashset类" class="headerlink" title="hashset类"></a>hashset类</h5><p>HashSet 的实现其实非常简单，它只是封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。 </p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><strong>Map接口</strong></h4><p>　　Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p>
<h5 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="　Hashtable类"></a>　<strong>Hashtable类</strong></h5><p>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。<br>　　添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。</p>
<p>使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”：<br>　　　　Hashtable numbers = new Hashtable();<br>　　　　numbers.put(“one”, new Integer(1));<br>　　　　numbers.put(“two”, new Integer(2));<br>　　　　numbers.put(“three”, new Integer(3));<br>　　要取出一个数，比如2，用相应的key：<br>　　　　Integer n = (Integer)numbers.get(“two”);</p>
<p>由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方 法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相 同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如 果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希 表的操作。<br>　　如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。<br>　　Hashtable是同步的。</p>
<p><strong>HashMap类</strong></p>
<p>hashmap源码详细讲解<a href="http://www.cnblogs.com/ITtangtang/p/3948406.html" target="_blank" rel="external">http://www.cnblogs.com/ITtangtang/p/3948406.html</a></p>
<p>　　HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例</p>
<p><strong>总结</strong>　　如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。<br>　　如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。<br>　　<strong>要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</strong><br>　　尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</p>
<h4 id="相互区别"><a href="#相互区别" class="headerlink" title="相互区别"></a><strong>相互区别</strong></h4><p><strong>Vector和ArrayList</strong></p>
<p>1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用</p>
<p>arraylist效率比较高。<br>2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度</p>
<p>的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。<br>3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而</p>
<p>如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据</p>
<p>所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。</p>
<p>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要 差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p>
<p><strong>arraylist和linkedlist</strong></p>
<p>1.ArrayList是实现了基于动态数组的<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">数据结构</a>，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>    这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数 据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p>
<p><strong>HashMap与TreeMap</strong>        (注)<br>       文章出处：<a href="http://www.diybl.com/course/3_program/java/javaxl/200875/130233.html" target="_blank" rel="external">http://www.diybl.com/course/3_program/java/javaxl/200875/130233.html</a><br>       1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</p>
<p>2, 、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。　　这个TreeMap没有调优选项，因为该树总处于平衡状态。</p>
<p><strong>hashtable与hashmap</strong></p>
<p>一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现</p>
<p>二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的</p>
<p>三.值：只有HashMap可以让你将空值作为一个表的条目的key或value</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/java-API/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-java-oop" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/java-oop/">java oop（基础整理）</a>
    </h1>
  

        <a href="/2016/12/11/java-oop/" class="archive-article-date">
  	<time datetime="2016-12-11T01:58:25.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="JavaBean规范"><a href="#JavaBean规范" class="headerlink" title="JavaBean规范"></a>JavaBean规范</h5><pre><code>1 类一定要有默认构造方法。

2 属性要private。

3 通过public的方法来操作属性。
</code></pre><h5 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h5><h5 id="可以修饰三个对象"><a href="#可以修饰三个对象" class="headerlink" title="可以修饰三个对象"></a>可以修饰三个对象</h5><pre><code> 1 变量：局部变量，常量，值不可改变。

    类中的属性：

       1 属性可以初始化，但不能通过set方法赋值。

       2 属性的初始化一定要使用类的构造方法，所以默认构造方法不可     用。

    基本数据类型：值不可改变。

    引用数据类型：引用不可改变。

2方法：方法不可改变。方法不能被重写。

3类：类不可改变。类不能被继承。
</code></pre><h5 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h5><pre><code>叫静态修饰符。

1 代码块：静态代码块，静态块。

   代码块：{  }

   静态代码块：static{ }

   给静态属性初始化用的。

2 属性：静态属性

   没加的static的属性叫实例属性。是实例的。

   加了static叫静态属性，也叫类属性。是类的。
</code></pre><p>静态方法只可以访问静态属性和静态方法。</p>
<h1 id="abstract修饰符"><a href="#abstract修饰符" class="headerlink" title="abstract修饰符"></a>abstract修饰符</h1><pre><code>Abstract中文叫抽象。

可以修饰二个地方：方法和类。
</code></pre><h2 id="6-1-抽象方法："><a href="#6-1-抽象方法：" class="headerlink" title="6.1 抽象方法："></a>6.1 抽象方法：</h2><pre><code>使用abstract修饰符修饰的方法。

抽象方法有自己的固定格式：没有方法体。
</code></pre><h5 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h5><pre><code>类前面加abstract修饰符的类,叫抽象类。

一个类中如果有抽象方法，这个类必须是抽象类。

在一个抽象类中可以有属性，方法，抽象方法，但也可不存在抽象方法。

抽象类不能被实例化。

抽象类在使用时一定要做为父类，让子类继承，重写抽象方法。
</code></pre><h5 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h5><p>1 公有静态常量，publicstatic final</p>
<p> 2 公有抽象方法，抽象方法的修饰符abstract。但是在接口中只能有抽象方法，在接口可以省略abstract</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>1 不能被new，实例化。</p>
<p>2 一定要找一个类，去实现接口。关键字implements</p>
<p> 在实现类中一定要对接口中声明的抽象方法给出具体的实现。重写接口中的抽象方法。</p>
<pre><code>4 当实现类中不能将接口中所有的抽象方法全部给出实现时，这个实现类就必须是抽象类。

5 接口同样支持面向对象的多态这个特性。

   接口类型的引用可以指向一个其实现类的实例。

   接口类型  接口类型引用 = new 实现类（）;

6 一个类只能继承自一个父类。Extends 类 只能有一个。Java是一种单继承的语言。

7 一个类可以实现多个接口。Implements 接口1，接口2

8 一个类可以同时继承一个父类，再同时实现多个接口。
</code></pre><h5 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h5><p>在实例内部代表实例本身的一个引用。一般在参数名称与属性名称一致时，用来区分哪个是属性用的。在属性前面加上”this.”</p>
<p>this关键字在实例内部可以调用三个内容：</p>
<pre><code>1属性：调用实例本身自己的属性。

    this.属性名

2方法：调用实例本身自己的方法。

    this.方法名（）;

3构造方法：调用实例本身自己的构造方法。

    this();

    只能写在构造方法中。

    只能写在构造方法的第一行
</code></pre><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>构造方法是一个特殊的方法。</p>
<pre><code>1 方法名称必须与类名一致。完全一致。大小写都要一致。

2 方法没有返回类型说明。注意不是没有返回值，是没有返回类型的说明。
</code></pre><p>构造方法是在new时（实例化），由系统自动调用的方法。（在实例化一个类的对象的过程中一同类同名不同参：</p>
<p>在一个类中有多个同名的方法，但是方法的参数不同时，把这几个同名的方法叫方法重载。</p>
<pre><code>参数不同包含：

   1参数个数。

   2参数类型。



构造方法也是方法，所以构造方法也可以重载。定要调用构造方法） 构造方法的作用是用来构造实例并初始化属性。
</code></pre><p><strong>方法重载</strong></p>
<p>同类同名不同参：</p>
<p>在一个类中有多个同名的方法，但是方法的参数不同时，把这几个同名的方法叫方法重载。</p>
<pre><code>参数不同包含
</code></pre><p>​       1参数个数。</p>
<pre><code>   2参数类型。

构造方法也是方法，所以构造方法也可以重载。
</code></pre><h5 id="面向对象的三大特性-封装，继承，多态"><a href="#面向对象的三大特性-封装，继承，多态" class="headerlink" title="面向对象的三大特性-封装，继承，多态"></a>面向对象的三大特性-封装，继承，多态</h5><p>封装的目的是为了实现模块化开发。</p>
<p> 具体体现方式：封装的目的是为了获得类和方法。</p>
<h6 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h6><p>private : 私有，只能类内使用。子类不能访问。</p>
<p>（default）：默认，包级别，本类和同包可用。</p>
<p>   protected：保护，同包和子类。</p>
<p>   public ： 公有，任何位置都可以访问</p>
<h5 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h5><pre><code>子类可以复用父类中的属性和方法。（必须参考访问修饰符，如果属性或方法是以private修饰时，在子类中不能使用父类的方法了。）继承不是单纯的代码复制。会为这个子类在创建子类实例时同时也创建一个属于这个子类实例的父类实例。  Java会为每个子类实例都关联一个父类实例。
</code></pre><h5 id="方法重写-Override"><a href="#方法重写-Override" class="headerlink" title="方法重写(Override)"></a>方法重写(Override)</h5><p>两个类要有继承关系。  在子类重新编写相同的方法。方法名称，返回类型，参数都必须相同。 我们就叫方法重写</p>
<h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a><strong>super关键字</strong></h5><p>在实例内部引用其父类实例的一个引用。使用super关键字可以调用父类的属性和方法。</p>
<pre><code>关于super常见的用法 

   1super.父类方法（）;   调用父类的方法。一般在子类重写的方法中调用父类的方法。
</code></pre><p>​       2 super（）;               调用父类的构造方法。只能在子类的构造方法的第一行出现。用来明确指定调用父类的哪个构造方法。</p>
<p>在没有多态时，使用继承的目的是为了代码复用。</p>
<pre><code>在没有多态时，使用继承的目的是为了修改现有类，创建新类。
</code></pre><h5 id="多态（是面向对象语言的最核心的特性）"><a href="#多态（是面向对象语言的最核心的特性）" class="headerlink" title="多态（是面向对象语言的最核心的特性）"></a>多态（是面向对象语言的最核心的特性）</h5><h6 id="多态的基础："><a href="#多态的基础：" class="headerlink" title="多态的基础："></a>多态的基础：</h6><pre><code> 1 要有继承：extends

2要有方法重写：在子类中重写父类继承的方法。声明一个与父类一样的方法。但是方法的内容可以重新写。
</code></pre><h2 id="多态的格式："><a href="#多态的格式：" class="headerlink" title="多态的格式："></a>多态的格式：</h2><pre><code>父类引用指向子类实例    父类类型 父类引用  = new 子类类型();
</code></pre><p>​     父类引用指向了一个子类的实例时，父类引用可以调用二类方法。</p>
<pre><code>1父类中声明的自己的方法。

2 子类中重写父类的方法。
</code></pre><h6 id="多态的一般使用方法的格式："><a href="#多态的一般使用方法的格式：" class="headerlink" title="多态的一般使用方法的格式："></a>多态的一般使用方法的格式：</h6><pre><code>1将父类引用做为方法的形参。

2将子类实例做为方法的实参。
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaoop/">javaoop</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/java-oop/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-java1" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/java1/">java基础整理</a>
    </h1>
  

        <a href="/2016/12/11/java1/" class="archive-article-date">
  	<time datetime="2016-12-11T01:31:16.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>JAVA程序运行过程中，有一个线程叫垃圾回收线程。程序运行了一时间之后很多垃圾信息。回收。</p>
<pre><code>自动调用。程序员不能控制。1 内存不够。2 CPU空闲。

垃圾：没有被引用的内存空间。
</code></pre><h5 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h5><p>Java先编译后解释型语言。</p>
<pre><code>源文件(.java)----编译-&gt;类文件(.class)（字节码文件）---解释执行（JVM：java虚拟机）---&gt;机器指令
</code></pre><p>JDK(Java Development Kit) Java开发工具包 </p>
<p>   JDK = JRE + 工具（编译器、调试器、其他工具……） + 类库 </p>
<p>JRE (Java Runtime Environment)  Java运行时环境 </p>
<p>  JRE = JVM(Java Virtual Machine) Java虚拟机+解释器 </p>
<p><img src="\images\javamodel.png" alt="javamodel"></p>
<p>原始数据类型就只有8个：byte,short,int,long  </p>
<p>float,double  char   boolean</p>
<h5 id="String字符串数据类型"><a href="#String字符串数据类型" class="headerlink" title="String字符串数据类型"></a>String字符串数据类型</h5><p>String实际上它是一个类,</p>
<p>字符串不变性：表示字符串字面量是不会改变的。</p>
<p>字符串常量池。用来存放字符串常量</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组就是保存同一类型的一大堆的变量。</p>
<p>声明一个数组。   int[] a; 推荐使用。</p>
<p>数组的异常- ArrayIndexOutOfBoundsException（索引超出范围）</p>
<p><strong>数组是引用数据类型</strong></p>
<p>当一个数组给另一个数组，使用数组名称赋值时，实际上是将数组的引用交给另一个数组。</p>
<p>两个数组使用的是同一块内存，两个数组引用是相同的。</p>
<p>所以一个数组对数组元素的修改等于两个数组一起改变。</p>
<h6 id="java-util-Arrays类。封装了针对数组的操作方法。"><a href="#java-util-Arrays类。封装了针对数组的操作方法。" class="headerlink" title="java.util.Arrays类。封装了针对数组的操作方法。"></a>java.util.Arrays类。封装了针对数组的操作方法。</h6><p> sort。排序方法。sort(byte[] a)对指定的 byte 型数组按数字升序进行排序。</p>
<p>binarySearch(int[]a,int key)</p>
<pre><code>使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。 
</code></pre><p>参数： </p>
<pre><code>a - 要搜索的数组 

key - 要搜索的值 
</code></pre><p>返回： </p>
<pre><code>如果它包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。*插入点* 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 a.length。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
</code></pre><p>copyOf使用老数组创建一个新的数组。同时拷贝数据。</p>
<h5 id="二维数组和多维数组"><a href="#二维数组和多维数组" class="headerlink" title="二维数组和多维数组"></a>二维数组和多维数组</h5><p>二维数组是否可以排序？不能，会报ClassCastException异常。</p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>为什么要创建函数？</p>
<pre><code>一个函数代表了一个功能。功能最好单一，独立，不可拆分。

可以重复使用

调用方便

结构清晰，层次更明确，修改容易。

可以利用函数将多层的循环变成多个一层的循环。

为了给我们的程序分模块。
</code></pre><p>“</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/java1/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-multithreading" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/10/multithreading/">multithreading</a>
    </h1>
  

        <a href="/2016/12/10/multithreading/" class="archive-article-date">
  	<time datetime="2016-12-10T14:50:56.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-10</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>参考<a href="http://blog.csdn.net/yaosiming2011/article/details/44280797" target="_blank" rel="external">进程和线程区别</a></p>
<h6 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h6><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>
<p>一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>2.关系</p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。</p>
<p>3.区别</p>
<p>进程和线程的主要差别在于它们是不同的<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="external">操作系统</a>资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<strong>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></p>
<p><strong>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</strong></p>
<p>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。<strong>但是线程不能够独立执行，</strong>必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。<strong>这就是进程和线程的重要区别。</strong></p>
<p>4.优缺点</p>
<p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>
<p>线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。</p>
<p><a href="http://blog.csdn.net/ITMagic_Jack/article/details/6196939" target="_blank" rel="external">http://blog.csdn.net/ITMagic_Jack/article/details/6196939</a></p>
<h4 id="二：在Java中实现多线程"><a href="#二：在Java中实现多线程" class="headerlink" title="二：在Java中实现多线程"></a>二：在<strong>Java</strong>中实现多线程</h4><p>继承 Thread 类，覆盖方法 run()： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">[java] view plain copy</div><div class="line"></div><div class="line"><span class="number">1</span>.     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FishMeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">2</span>.       </div><div class="line"></div><div class="line"><span class="number">3</span>.           <span class="keyword">int</span> count= <span class="number">1</span>, number;  </div><div class="line"></div><div class="line"><span class="number">4</span>.            </div><div class="line"></div><div class="line"><span class="number">5</span>.           <span class="function"><span class="keyword">public</span> <span class="title">FishMeThread</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">6</span>.                 number = num;  </div><div class="line"></div><div class="line"><span class="number">7</span>.                 System.out.println(<span class="string">"创建线程 "</span> + number);  </div><div class="line"></div><div class="line"><span class="number">8</span>.           &#125;  </div><div class="line"></div><div class="line"><span class="number">9</span>.       </div><div class="line"></div><div class="line"><span class="number">10</span>.       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">11</span>.             <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </div><div class="line"></div><div class="line"><span class="number">12</span>.                  System.out.println(<span class="string">"线程 "</span> + number + <span class="string">":计数 "</span> + count);  </div><div class="line"></div><div class="line"><span class="number">13</span>.                  <span class="keyword">if</span>(++count== <span class="number">6</span>) <span class="keyword">return</span>;  </div><div class="line"></div><div class="line"><span class="number">14</span>.             &#125;  </div><div class="line"></div><div class="line"><span class="number">15</span>.       &#125;  </div><div class="line"></div><div class="line"><span class="number">16</span>.   </div><div class="line"></div><div class="line"><span class="number">17</span>.       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">18</span>.             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </div><div class="line"></div><div class="line"><span class="number">19</span>.                   <span class="keyword">new</span> FishMeThread(i + <span class="number">1</span>).start();  </div><div class="line"></div><div class="line"><span class="number">20</span>.             &#125;   </div><div class="line"></div><div class="line"><span class="number">21</span>.       &#125;  </div><div class="line"></div><div class="line"><span class="number">22</span>.   </div><div class="line"></div><div class="line"><span class="number">23</span>. &#125;</div></pre></td></tr></table></figure>
<pre><code>方法二：实现 Runnable 接口：  
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">[java] view plain copy</div><div class="line"></div><div class="line"><span class="number">1</span>.     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FishMeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">2</span>.       </div><div class="line"></div><div class="line"><span class="number">3</span>.           <span class="keyword">int</span> count= <span class="number">1</span>, number;  </div><div class="line"></div><div class="line"><span class="number">4</span>.       </div><div class="line"></div><div class="line"><span class="number">5</span>.           <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">6</span>.                 number = num;  </div><div class="line"></div><div class="line"><span class="number">7</span>.                 System.out.println(<span class="string">"创建线程 "</span> + number);  </div><div class="line"></div><div class="line"><span class="number">8</span>.           &#125;  </div><div class="line"></div><div class="line"><span class="number">9</span>.       </div><div class="line"></div><div class="line"><span class="number">10</span>.       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">11</span>.             <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;  </div><div class="line"></div><div class="line"><span class="number">12</span>.                   System.out.println(<span class="string">"线程 "</span> + number + <span class="string">":计数 "</span> + count);  </div><div class="line"></div><div class="line"><span class="number">13</span>.                   <span class="keyword">if</span>(++count== <span class="number">6</span>) <span class="keyword">return</span>;  </div><div class="line"></div><div class="line"><span class="number">14</span>.             &#125;   </div><div class="line"></div><div class="line"><span class="number">15</span>.       &#125;  </div><div class="line"></div><div class="line"><span class="number">16</span>.   </div><div class="line"></div><div class="line"><span class="number">17</span>.       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line"></div><div class="line"><span class="number">18</span>.             <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </div><div class="line"></div><div class="line"><span class="number">19</span>.                   <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i+<span class="number">1</span>)).start();  </div><div class="line"></div><div class="line"><span class="number">20</span>.             &#125;   </div><div class="line"></div><div class="line"><span class="number">21</span>.       &#125;  </div><div class="line"></div><div class="line"><span class="number">22</span>.   </div><div class="line"></div><div class="line"><span class="number">23</span>. &#125;</div></pre></td></tr></table></figure>
<p>将我们希望线程执行的代码放到run方法中，然后通过start方法来启动线程，start方法首先为线程的执行准备好系统资源，然后再去调用run方法。当某个类继承了Thread类之后，该类就叫做一个线程类。 </p>
<h4 id="三、Thread源码研究："><a href="#三、Thread源码研究：" class="headerlink" title="三、Thread源码研究："></a>三、Thread源码研究：</h4><p>1) Thread类也实现了Runnable接口，因此实现了Runnable接口中的run方法；<br>2) 当生成一个线程对象时，如果没有为其设定名字，那么线程对象的名字将使用如下形式：Thread-number,该number将是自动增加的，并被所有的Thread对象所共享（因为它是static的成员变量）。<br>3) 当使用第一种方式来生成线程对象时，我们需要重写run方法，因为Thread类的run方法此时什么事情也不做。<br>4）当使用第二种方式生成线程对象时，我们需要实现Runnable接口的run方法，然后使用new Thread（new MyThread（））（假如MyThread已经实现了Runnable接口）来生成线程对象，这时的线程对象的run方法或调就会MyThread类的run方法，这样我们自己编写的run方法就执行了。<br>当使用继承Thread生成线程对象时，target为空，什么也不执行，当使用第二种方式生成时，执行target.run（），target为runnable的实例对象，即为执行重写后的方法<br>总结：两种生成线程对象的区别：<br>1.两种方法均需执行线程的start方法为线程分配必须的系统资源、调度线程运行并执行线程的run方法。<br>2.在具体应用中，采用哪种方法来构造线程体要视情况而定。通常，当一个线程已继承了另一个类时，就应该用第二种方法来构造，即实现Runnable接口。 </p>
<h4 id="三：线程的四种状态"><a href="#三：线程的四种状态" class="headerlink" title="三：线程的四种状态"></a>三：线程的四种状态</h4><ol>
<li>新状态：线程已被创建但尚未执行（start() 尚未被调用）。</li>
<li>可执行状态：线程可以执行，虽然不一定正在执行。CPU 时间随时可能被分配给该线程，从而使得它执行。</li>
<li>死亡状态：正常情况下 run() 返回使得线程死亡。调用 stop()或 destroy() 亦有同样效果，但是不被推荐，前者会产生异常，后者是强制终止，不会释放锁。</li>
<li>阻塞状态：线程不会被分配 CPU 时间，无法执行。</li>
</ol>
<h4 id="四：线程的优先级"><a href="#四：线程的优先级" class="headerlink" title="四：线程的优先级"></a>四：线程的优先级</h4><p>线程的优先级代表该线程的重要程度，当有多个线程同时处于可执行状态并等待获得 CPU 时间时，线程调度系统根据各个线程的优先级来决定给谁分配 CPU 时间，优先级高的线程有更大的机会获得 CPU 时间，优先级低的线程也不是没有机会，只是机会要小一些罢了。<br>你可以调用 Thread 类的方法 getPriority() 和 setPriority()来存取线程的优先级，线程的优先级界于1(MIN_PRIORITY)和10(MAX_PRIORITY)之间，缺省是5(NORM_PRIORITY)。</p>
<h4 id="五：线程的同步"><a href="#五：线程的同步" class="headerlink" title="五：线程的同步"></a>五：线程的同步</h4><p><a href="http://www.2cto.com/kf/201408/324061.html" target="_blank" rel="external">http://www.2cto.com/kf/201408/324061.html</a><br>由于同一进程的多个线程共享同一片存储空间，在带来方便的同时，也带来了访问冲突这个严重的问题。Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问。<br>由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，这套机制就是 synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。</p>
<ol>
<li><p>synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如：</p>
<p>public synchronized void accessVal(int newVal);<br>synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。<br>在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。<br>synchronized 方法的缺陷：若将一个大的方法声明为synchronized<br>将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。</p>
</li>
<li><p>synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下： </p>
</li>
</ol>
<p>synchronized(syncObject) {<br>  //允许访问控制的代码<br>}<br>synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。</p>
<p>​     3.使用特殊域变量(volatile)实现线程同步</p>
<p>   a.volatile关键字为域变量的访问提供了一种免锁机制， </p>
<p>   b.使用volatile修饰域相当于告诉<a href="http://www.2cto.com/os/xuniji/" target="_blank" rel="external">虚拟机</a>该域可能会被其他线程更新， </p>
<p>   c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 </p>
<p>   d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 </p>
<p>   注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 </p>
<p>   用final域，有锁保护的域和volatile域可以避免非同步的问题。  </p>
<p>4.使用重入锁实现线程同步</p>
<p>   在<a href="http://www.2cto.com/kf/ware/Java/" target="_blank" rel="external">Java</a>SE5.0中新增了一个java.util.concurrent包来支持同步。 </p>
<p>   ReentrantLock类是可重入、互斥、实现了Lock接口的锁， </p>
<p>   它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力</p>
<p>   ReenreantLock类的常用方法有：</p>
<p>   ReentrantLock() : 创建一个ReentrantLock实例 </p>
<pre><code>lock() : 获得锁 

unlock() : 释放锁 
</code></pre><p>   注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 </p>
<p>   注：关于Lock对象和synchronized关键字的选择： </p>
<pre><code>a.最好两个都不用，使用一种java.util.concurrent包提供的机制， 

    能够帮助用户处理所有与锁相关的代码。 

b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 

c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁       
</code></pre><p>5.使用局部变量实现线程同步 </p>
<p>   如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， </p>
<p>   副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p>
<p> ThreadLocal 类的常用方法</p>
<p>   ThreadLocal() : 创建一个线程本地变量 </p>
<p>   get() : 返回此线程局部变量的当前线程副本中的值 </p>
<p>   initialValue() : 返回此线程局部变量的当前线程的”初始值” </p>
<p>   set(T value) : 将此线程局部变量的当前线程副本中的值设置为value</p>
<h5 id="ThreadLocal与同步机制"><a href="#ThreadLocal与同步机制" class="headerlink" title="ThreadLocal与同步机制"></a>ThreadLocal与同步机制</h5><pre><code>a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 

b.前者采用以&quot;空间换时间&quot;的方法，后者采用以&quot;时间换空间&quot;的方式 
</code></pre><h4 id="六：线程的阻塞"><a href="#六：线程的阻塞" class="headerlink" title="六：线程的阻塞"></a>六：线程的阻塞</h4><p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持。<br>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>
<ol>
<li>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：<strong>测试</strong>发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li>
<li>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</li>
<li>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。</li>
<li>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。</li>
</ol>
<p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。<br>上述的核心区别导致了一系列的细节上的区别。<br>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。<br>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。<br>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的<strong>算法</strong>（如信号量算法），并用于解决各种复杂的线程间通信问题。<br>关于 wait() 和 notify() 方法最后再说明两点：<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。<br>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。<br>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。<br>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>
<p>生产者消费者模型</p>
<p><a href="http://blog.csdn.net/zhangyuan19880606/article/details/51153035" target="_blank" rel="external">http://blog.csdn.net/zhangyuan19880606/article/details/51153035</a></p>
<p>一种重要的模型，基于等待/通知机制。生产者/消费者模型描述的是有一块缓冲区作为仓库，生产者可将产品放入仓库，消费者可以从仓库中取出产品，生产者/消费者模型关注的是以下几个点：</p>
<p>1、生产者生产的时候消费者不能消费</p>
<p>2、消费者消费的时候生产者不能生产</p>
<p>3、缓冲区空时消费者不能消费</p>
<p>4、缓冲区满时生产者不能生产</p>
<p>生产者/模型作为一种重要的模型，它的优点在于：</p>
<p>1、解耦。因为多了一个缓冲区，所以生产者和消费者并不直接相互调用，这一点很容易想到，这样生产者和消费者的代码发生变化，都不会对对方产生影响，这样其实就把生产者和消费者之间的强耦合解开，变为了生产者和缓冲区/消费者和缓冲区之间的弱耦合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">** </div><div class="line"> * 公共资源类 </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublicResource</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 增加公共资源 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increace</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                wait();  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        number++;  </div><div class="line">        System.out.println(number);  </div><div class="line">        notify();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 减少公共资源 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decreace</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                wait();  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        number--;  </div><div class="line">        System.out.println(number);  </div><div class="line">        notify();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>二，分别定义生产者线程和消费者线程，并模拟多次生产和消费，即增加和减少公共资源的number值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 生产者线程，负责生产公共资源 </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> PublicResource resource;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerThread</span><span class="params">(PublicResource resource)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.resource = resource;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">            resource.increace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">/** </span></div><div class="line"> * 消费者线程，负责消费公共资源 </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> PublicResource resource;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(PublicResource resource)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.resource = resource;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">            resource.decreace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>三，模拟多个生产者和消费者操作公共资源的情形，结果须保证是在允许的范围内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        PublicResource resource = <span class="keyword">new</span> PublicResource();  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ProducerThread(resource)).start();  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerThread(resource)).start();  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ProducerThread(resource)).start();  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerThread(resource)).start();  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ProducerThread(resource)).start();  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConsumerThread(resource)).start();  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>生产数据和消费数据一定是成对出现的，生产一个消费一个，满了不生产，空了不消费，生产者不能无限生产，消费者也不能无限消费，符合生产者/消费者模型。生产者速度快，就不占用CPU时间片，等着消费者消费完通知它继续生产，这块时间片可以用来给其他线程用。</p>
<h4 id="七：守护线程"><a href="#七：守护线程" class="headerlink" title="七：守护线程"></a>七：守护线程</h4><p>守护线程是一类特殊的线程，它和普通线程的区别在于它并不是应用程序的核心部分，当一个应用程序的所有非守护线程终止运行时，即使仍然有守护线程在运行，应用程序也将终止，反之，只要有一个非守护线程在运行，应用程序就不会终止。守护线程一般被用于在后台为其它线程提供服务。</p>
<p>可以通过调用方法 isDaemon() 来判断一个线程是否是守护线程，也可以调用方法 setDaemon() 来将一个线程设为守护线程。</p>
<p>死锁：<strong>产生死锁的四个必要条件：</strong></p>
<p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>锁的类别有两种分法：  </p>
<ol>
<li>从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁  </li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">1.	&lt;span style="font-size:18px;"&gt;class Test implements Runnable  </div><div class="line">2.	&#123;  </div><div class="line">3.	    private boolean flag; //flag标签，让t1和t2线程执行不同代码  </div><div class="line">4.	    public Test(boolean flag)  </div><div class="line">5.	    &#123;  </div><div class="line">6.	        this.flag=flag;  </div><div class="line">7.	    &#125;  </div><div class="line">8.	    public void run()  </div><div class="line">9.	    &#123;  </div><div class="line">10.	        if (flag)    </div><div class="line">11.	        &#123;  </div><div class="line">12.	            synchronized(MyLock.lock1)  </div><div class="line">13.	            &#123;  </div><div class="line">14.	                System.out.println("if1");  </div><div class="line">15.	  </div><div class="line">16.	                synchronized(MyLock.lock2)  </div><div class="line">17.	                &#123;  </div><div class="line">18.	                System.out.println("if2");  </div><div class="line">19.	                &#125;  </div><div class="line">20.	            &#125;  </div><div class="line">21.	        &#125;  </div><div class="line">22.	        else  </div><div class="line">23.	        &#123;  </div><div class="line">24.	            synchronized(MyLock.lock2)  </div><div class="line">25.	            &#123;  </div><div class="line">26.	                System.out.println("else2");  </div><div class="line">27.	  </div><div class="line">28.	                synchronized(MyLock.lock1)  </div><div class="line">29.	                &#123;  </div><div class="line">30.	                System.out.println("else1");  </div><div class="line">31.	                &#125;  </div><div class="line">32.	            &#125;  </div><div class="line">33.	        &#125;  </div><div class="line">34.	      </div><div class="line">35.	    &#125;  </div><div class="line">36.	  </div><div class="line">37.	      </div><div class="line">38.	&#125;  </div><div class="line">39.	  </div><div class="line">40.	class MyLock  //两个锁，用来制造死锁  </div><div class="line">41.	&#123;  </div><div class="line">42.	    public static Object lock1 = new Object();  </div><div class="line">43.	    public static Object lock2 = new Object();  </div><div class="line">44.	  </div><div class="line">45.	&#125;  </div><div class="line">46.	  </div><div class="line">47.	class DeadLock   </div><div class="line">48.	&#123;  </div><div class="line">49.	    public static void main(String[] args)   </div><div class="line">50.	    &#123;   </div><div class="line">51.	        Thread t1 = new Thread(new Test(true)); //t1先用锁1再用锁2  </div><div class="line">52.	        Thread t2 = new Thread(new Test(false));//t2先用锁2再用锁1  </div><div class="line">53.	          </div><div class="line">54.	        t1.start();  </div><div class="line">55.	        t2.start();  </div><div class="line">56.	          </div><div class="line">57.	    &#125;  </div><div class="line">58.	&#125;  </div><div class="line">59.	&lt;/span&gt;</div></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/10/multithreading/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 caroltuan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js?v=4.0.0.js"></script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">JDBC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">ajax</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">learning</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">json</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">javaoop</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">jsp servlet</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">throwable</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">多线程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">API</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://shinerio.cc" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>自恋瑞的blog</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">一只团&lt;br&gt;&lt;br&gt;一只想要认真学习的团</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>