<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Carol</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Carol">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Carol">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Carol">
  
    <link rel="alternative" href="/atom.xml" title="Carol" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/avatar.png">
  
  <link rel="stylesheet" href="/main.css?v=4.0.0.css">
  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/avatar.png" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">caroltuan</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Carol&#39;s blog</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a data-idx="0" q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a data-idx="1" q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a data-idx="2" q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://caroltuan.github.io/" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/3908875562?refer_flag=1001030102_&is_all=1" title="weibo"><i class="icon-weibo"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-sort"></i></div>
  		<h1 class="header-author js-mobile-header hide">caroltuan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">caroltuan</h1>
			</hgroup>
			
			<p class="header-subtitle">Carol&#39;s blog</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
		        
		        	<li><a href="/archives/">所有文章</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://caroltuan.github.io/" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3908875562?refer_flag=1001030102_&is_all=1" title="weibo"><i class="icon-weibo"></i></a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-Hibernate" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/21/Hibernate/">Hibernate</a>
    </h1>
  

        <a href="/2016/12/21/Hibernate/" class="archive-article-date">
  	<time datetime="2016-12-21T01:04:55.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-21</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hibernate是一个基于ORM的封装JDBC的持久化框架</p>
<p>ORM（Object Relational Mapping对象关系映射）</p>
<p>描述一个类与一个表之间的映射关系</p>
<h5 id="Hibernate核心API"><a href="#Hibernate核心API" class="headerlink" title="Hibernate核心API"></a>Hibernate核心API</h5><p>Session接口：整个Hibernate中核心接口，负责连接数据库对数据库表实现CRUD的操作。这个接口中封装了实现CRUD操作的方法。</p>
<h5 id="SessionFactory接口"><a href="#SessionFactory接口" class="headerlink" title="SessionFactory接口"></a>SessionFactory接口</h5><p>Session工厂要读取一个“hibernate.cfg.xml”文件来创建session对象。</p>
<h5 id="Configuration类"><a href="#Configuration类" class="headerlink" title="Configuration类"></a>Configuration类</h5><p>读hibernate.cfg.xml文件。创建sessionFactory工厂。</p>
<h5 id="Transaction接口"><a href="#Transaction接口" class="headerlink" title="Transaction接口"></a>Transaction接口</h5><p>Hibernate中的事务对象。</p>
<p>获得一个事务对象。<br>Transaction tran = session.getTransaction();</p>
<p>开始事务: tran.begin();<br>提交事务: tran.commit();<br>回滚事务: tran.rollback();</p>
<h5 id="Query接口"><a href="#Query接口" class="headerlink" title="Query接口"></a>Query接口</h5><p>负责执行HQL语句。查询数据库。实现更复杂的数据库查询功能。</p>
<h6 id="对比SessionFactory对象openSession-方法与getCurrentSession-方法。"><a href="#对比SessionFactory对象openSession-方法与getCurrentSession-方法。" class="headerlink" title="对比SessionFactory对象openSession()方法与getCurrentSession()方法。"></a>对比SessionFactory对象openSession()方法与getCurrentSession()方法。</h6><p>openSession()方法比较单纯。获得一个新的session对象。<br>一个新的session对象就是一个新的数据库连接对象。在使用事务的环境时不能直接使用。</p>
<p>getCurrentSession()：获得当前线程中的session对象。就是为了维护事务操作。</p>
<p>注意1：在hibernate.cfg.xml文件中要进行配置。</p>
<property name="current_session_context_class">thread</property>

<p>注意2：一定要在事务的环境下使用session对象。<br>注意3：session对象不需要手动调用close()方法关闭，当事务提交或回滚时自动关闭。</p>
<h5 id="主键生成策略generator"><a href="#主键生成策略generator" class="headerlink" title="主键生成策略generator"></a>主键生成策略generator</h5><p>详解：<a href="http://blog.csdn.net/wanghuan203/article/details/7562395" target="_blank" rel="external">http://blog.csdn.net/wanghuan203/article/details/7562395</a></p>
<p> 1、increment:最大值加一  mysql  由底层数据库负责</p>
<p>2、identity：自动增长，针对mysql ,sqlserver，db2，由底层数据库负责。</p>
<p>3、sequence：序列，针对Oracle，由底层数据库负责。</p>
<p>4、uuid：select sys_guid() as uuid from dual;由底层数据库负责。</p>
<p>5、assigned：手动指定。由程序。</p>
<p>6、native：根据底层数据库的能力选择identity, sequence 或者hilo中的一个</p>
<p>延迟加载 lazy：不使用不查询。什么时候使用什么时候再去查询。</p>
<p>延迟加载必须保存是同一个会话(session)对象。不能关闭会话对象</p>
<p>session对象中加载数据方法get和load的区别：</p>
<p>Get方法和load方法作用都是相同的：按主键查询对象。<br>Get方法表示取一个对象。<br>Load方法表示加载一个对象。</p>
<p>区别1：查询无结果时：</p>
<p>Get:查询无结果时返回null      Load:查询无结果时报异常。</p>
<p>区别2：查询结构返回的对象类型</p>
<p>Get:返回就是查询的类型对象本身。</p>
<p>Load:返回是查询对象类型的一个动态代理的对象。</p>
<p>区别3：使用ORM文件对于类本身的参数设置-lazy</p>
<p>Load方法类级Lazy起作用。</p>
<p>Get方法类级Lazy不起作用。</p>
<p>get方法首先查询session缓存，没有的话查询二级缓存，最后查询数据库；反而load方法创建时首先查询session缓存，没有就创建代理，实际使用数据时才查询二级缓存和数据库</p>
<h5 id="单表HQL查询"><a href="#单表HQL查询" class="headerlink" title="单表HQL查询"></a>单表HQL查询</h5><p>HQL语句的执行要使用Hibernate中提供的Query接口。</p>
<p>创建Query接口实例的方法：Query query = session.createQuery(HQL语句);</p>
<p>Query接口的返回数据的两个方法</p>
<p>1、 List list()：返回一个集合，当查询的结果为多条记录时</p>
<p>2、Object uniqueResult()：返回一个对象 ，当查询的结果确定只有一条记录时。</p>
<p>在HQL语句中可以使用？或:参数名的方法设置参数。</p>
<p>使用Query接口的setXXX方法给参数赋值。</p>
<p>使用query接口的setProperties（）方法可以一次性给多个参数赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hql05</span><span class="params">()</span></span>&#123;</div><div class="line">		Map&lt;String, Double &gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">		map.put(<span class="string">"minprice"</span>, <span class="number">5.0</span>);</div><div class="line">		map.put(<span class="string">"maxprice"</span>, <span class="number">50.0</span>);</div><div class="line">		</div><div class="line">		String hql =<span class="string">"from Goods where goodsPrice between  :minprice  and :maxprice "</span>;</div><div class="line">		Session session = getSession();</div><div class="line">		<span class="comment">//获得Query接口的实例 </span></div><div class="line">		Query query = session.createQuery(hql);</div><div class="line">		<span class="comment">//给参数赋值</span></div><div class="line">		query.setProperties(map);</div><div class="line">		List&lt;Goods&gt; goodsList = query.list();</div><div class="line">		<span class="keyword">for</span> (Goods goods : goodsList) &#123;</div><div class="line">			System.out.println(goods.getGoodsName());</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>select * 的语法格式在HQL语句中不能使用</p>
<p>投影查询select ：只查询表中的某几列</p>
<p>使用Map接口，在HQL语句使用AS声明别名，同时别名作为Map的Key。数据库中的值做为Map的Value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List <span class="title">find</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">     String hql=<span class="string">"select new Map(goodsname as name,goodsprice as price) from Goods orser by goodsprice desc"</span>;</div><div class="line">    Query queryObject=getSession().creatQuary(hql);</div><div class="line">    <span class="keyword">return</span> quaryObject.list();</div><div class="line">  &#125;<span class="keyword">catch</span>(RuntimeException re)&#123;</div><div class="line">    <span class="keyword">throw</span> re;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="HQL语句支持分页查询"><a href="#HQL语句支持分页查询" class="headerlink" title="HQL语句支持分页查询"></a>HQL语句支持分页查询</h5><p>在Query接口中提供了两个分页的方法。<br>setFirstResult():设置第一条记录的索引<br>setMaxResults():设置查询的最大返回记录数量</p>
<h5 id="关联关系映射-重点-多表。"><a href="#关联关系映射-重点-多表。" class="headerlink" title="关联关系映射(重点)-多表。"></a>关联关系映射(重点)-多表。</h5><p>确定关联关系的方式只有唯一的一种：主外键约束。</p>
<p>数据库中有几中关联关系的情况: 1:1 、 1:N 、 N:M（一定创建第三张关系表）</p>
<p>单向多对一(many to one)m2o、mto</p>
<p>就是在Hibernate中映射数据库中从N表的一方如何关联1表的一方。 </p>
<p> Many-to-one的属性</p>
<h6 id="lazy：“延迟策略”延迟加载。"><a href="#lazy：“延迟策略”延迟加载。" class="headerlink" title="lazy：“延迟策略”延迟加载。"></a>lazy：“延迟策略”延迟加载。</h6><p>在many-to-one这个节点上的lazy是，关联级别的延迟加载。</p>
<p>False:不延迟。立即加载。    Proxy:延迟加载。</p>
<h6 id="fetch：”抓取策略”，加载策略"><a href="#fetch：”抓取策略”，加载策略" class="headerlink" title="fetch：”抓取策略”，加载策略"></a>fetch：”抓取策略”，加载策略</h6><p>​        Join：会向数据库发送一次查询语句，使用连接查询的方式加载级联对象         (types)。当使用join时，延迟加载的设置将不起作用。</p>
<p>​    Select：使用单独的一条select语句去加载级联对象。当使用select时，延迟加载的设置才会起作用。</p>
<h4 id="双向一对多"><a href="#双向一对多" class="headerlink" title="双向一对多"></a>双向一对多</h4><p>双向映射：同时描述商品到类型和类型到商品。</p>
<p>商品是N<br>类型是1</p>
<p>商品到类型：many-to-one 就是在商品中有一个类型的实例。<br>类型到商品：one-to-many 就是在类型中有一个商品的集合。</p>
<p>小技巧总结：<br>xxx-to-one:就是一个实例。<br>xxx-to-many:就是一个set集合。</p>
<p>set的属性</p>
<p>1、 lazy延迟。Lazy=”true|false|extra”<br>在one-to-many时一定要延迟。<br>lazy=”extra”比true好一些。当我们程序只想知道集合大小时，可以使用count函数计算。</p>
<p>2、&lt;set inverse=”false|true”:是不是放弃控制级联对象的维护。False表示不放弃，true表示放弃。<br>双向维护。<br>一般实际开发中是一的一方放弃控制权。</p>
<p><img src="\images\hibernateset.png" alt="hibernateset"></p>
<p>Set的规则：<br>1、    双向一对多时，多方控制，一方放弃<set inverse="”true”">。<br>2、    一对多的映射时<one-to-many>时一定要延迟加载lazy=”extra”。<br>3、    一般情况在<many-to-one fetch="”join”">时我们可以不使用延迟加载。<br>4、    双向映射时，一定要在Java代码中双方同时维护关系。</many-to-one></one-to-many></set></p>
<p>QBC和QBE-Criteria</p>
<p>Query、Criteria、SqlQuery这三个接口<br>QBC中使用到下面的三个对象。<br>Criteria本身只是个查询容器，具体的查询条件需要通过Cretiria.add方法添加到Criteria实例中。<br>Restrictions的一系列静态方法可以创建Criterion对象，<br>Criterion具体描述查询条件，针对SQL语法，Criterion提供了对应的查询限定机制。 </p>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><p>Hibernate中的缓存三个：一级缓存，二级缓存，查询缓存</p>
<p>一级缓存-session缓存，默认使用。</p>
<p>二级缓存-sessionFactory缓存，就是为了处理多个session之间的数据缓存</p>
<p>查询缓存 查询缓存必须基于二级缓存的基础之上。</p>
<p>详解：<a href="http://www.iteye.com/topic/18904" target="_blank" rel="external">http://www.iteye.com/topic/18904</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/三大框架-hibernate/">三大框架 hibernate</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/21/Hibernate/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-ajax" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/ajax/">ajax</a>
    </h1>
  

        <a href="/2016/12/20/ajax/" class="archive-article-date">
  	<time datetime="2016-12-20T02:10:29.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Ajax是一个异步刷新的技术。可以现实在页面上的局部刷新。</p>
<p>Ajax技术实现只使用一个xhr对象。</p>
<h5 id="XHR对象的属性，方法和事件"><a href="#XHR对象的属性，方法和事件" class="headerlink" title="XHR对象的属性，方法和事件"></a>XHR对象的属性，方法和事件</h5><h6 id="用open方法创建一个请求"><a href="#用open方法创建一个请求" class="headerlink" title="用open方法创建一个请求"></a>用open方法创建一个请求</h6><p>​    open(method, url, asynchronous)<br>​    method: 请求类型。可以是get或post</p>
<p>​    url: 请求地址。可以使用绝对、相对地址，地址可以附带查询字符串</p>
<p>​    asynchronous: 可选参数，请求同步还是异步。默认为true（异步）</p>
<h6 id="用send方法发送一个请求"><a href="#用send方法发送一个请求" class="headerlink" title="用send方法发送一个请求"></a>用send方法发送一个请求</h6><p>​    send(parameter)<br>     发送无参数请求:send(null)</p>
<h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><p>onreadystatechange   每个状态改变时都会触发这个事件处理器，通常会调用一个 JavaScript</p>
<p>readyState    请求的状态，有5个可取值： 0=未初始化, 1=正在加载, 2=已加载, 3=交互中, 4=完成 </p>
<p>responseText   响应内容正文的纯文本形式 </p>
<p>responseXML  使用XML表示服务器的响应，这个对象可以解析为一个 DOM 对象 </p>
<p>status  服务器的 HTTP 状态码（200对应OK，404对应Not Found）</p>
<p>使用ajax实现一个请求</p>
<p>servlet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</div><div class="line"><span class="keyword">import</span> net.sf.json.JsonConfig;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.domain.Goods;</div><div class="line"><span class="keyword">import</span> com.domain.Types;</div><div class="line"></div><div class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"GoodsServlet"</span>, urlPatterns = &#123; <span class="string">"/find.do"</span> &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">			<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">		<span class="comment">// 获得商品的集合</span></div><div class="line">		List&lt;Goods&gt; goodsList = <span class="keyword">new</span> ArrayList&lt;Goods&gt;();</div><div class="line">		Types types = <span class="keyword">new</span> Types(<span class="number">1</span>, <span class="string">"手机"</span>);</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">1</span>, <span class="string">"小米1"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">2</span>, <span class="string">"小米2"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">3</span>, <span class="string">"小米3"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">4</span>, <span class="string">"小米4"</span>, types));</div><div class="line">		goodsList.add(<span class="keyword">new</span> Goods(<span class="number">5</span>, <span class="string">"小米5"</span>, types));</div><div class="line">		</div><div class="line">		<span class="comment">//把集合转成json数组,将json数组转成json文本</span></div><div class="line">		JsonConfig jsonConfig = <span class="keyword">new</span> JsonConfig();</div><div class="line">		jsonConfig.setExcludes(<span class="keyword">new</span> String[]&#123;<span class="string">"goodsSet"</span>&#125;);</div><div class="line">		JSONArray jsonArray = JSONArray.fromObject(goodsList,jsonConfig);</div><div class="line"></div><div class="line">		response.setContentType(<span class="string">"text/html"</span>);</div><div class="line">		response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line">		PrintWriter out = response.getWriter();</div><div class="line"></div><div class="line">		out.print(jsonArray.toString());</div><div class="line">		</div><div class="line">		out.flush();</div><div class="line">		out.close();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jsp</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=<span class="string">"expires"</span> content=<span class="string">"0"</span>&gt;</div><div class="line">&lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt;</div><div class="line">&lt;meta http-equiv="description" content="This is my page"&gt;</div><div class="line">&lt;!--</div><div class="line">	&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;</div><div class="line">	--&gt;</div><div class="line"></div><div class="line">&lt;script type="text/javascript" src="/ajaxjson/js/jquery-1.11.1.min.js"&gt;&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">$(document).ready(function()&#123;</div><div class="line">	$("#btnquery").click(function()&#123;</div><div class="line">		$.ajax(&#123;</div><div class="line">			type: 'get',</div><div class="line">			dataType: 'json',</div><div class="line">			url: '/ajaxjson/find.do',</div><div class="line">			data: &#123;"time":new Date()&#125;,</div><div class="line">			success: function(data)&#123;</div><div class="line">					var goodsbody = document.getElementById("goodsbody");</div><div class="line">					goodsbody.innerHTML = "";</div><div class="line">					for ( var i = 0; i &lt; data.length; i++) &#123;</div><div class="line">						var goodsTr = goodsbody.insertRow();</div><div class="line">						var goodsNameTd = goodsTr.insertCell();</div><div class="line">						goodsNameTd.innerText = data[i].gid;</div><div class="line">						var goodsPriceTd = goodsTr.insertCell();</div><div class="line">						goodsPriceTd.innerText = data[i].gname;</div><div class="line">						var goodsNumTd = goodsTr.insertCell();</div><div class="line">						goodsNumTd.innerText = data[i].types.tname;</div><div class="line">					&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">	&lt;input type="button" value="查询" id="btnquery"&gt;</div><div class="line">	&lt;table width="80%" cellpadding="0" border="1" cellspacing="0"&gt;</div><div class="line">		&lt;thead&gt;</div><div class="line">			&lt;tr&gt;</div><div class="line">				&lt;th&gt;商品编号&lt;/th&gt;</div><div class="line">				&lt;th&gt;商品名称&lt;/th&gt;</div><div class="line">				&lt;th&gt;商品类型&lt;/th&gt;</div><div class="line">			&lt;/tr&gt;</div><div class="line">		&lt;/thead&gt;</div><div class="line">		&lt;tbody id="goodsbody"&gt;&lt;/tbody&gt;</div><div class="line">	&lt;/table&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ajax/">ajax</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/20/ajax/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-json" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/json/">json</a>
    </h1>
  

        <a href="/2016/12/20/json/" class="archive-article-date">
  	<time datetime="2016-12-20T01:41:43.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-20</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSON是一种数据表示的格式，包括json对象和json数组。</p>
<h5 id="json的基本语法格式"><a href="#json的基本语法格式" class="headerlink" title="json的基本语法格式"></a>json的基本语法格式</h5><p>对象： { 属性：值 ， 属性：值 }</p>
<p>数组：[对象，对象，对象]<br>获得一个数组的大小 使用 length属性。</p>
<p>访问一个对象的属性：json对象.属性。。。。可以取值也可赋值。<br>访问一个数组中的元素的方式：json数组[索引]</p>
<p>JSON文本是一个符合JSON语法格式的字符串。因为服务器只能返回文本。</p>
<p>JSON文本转换成JSON对象使用eval函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> json对象 = <span class="built_in">eval</span>(“(“+json文本+”)”);</div></pre></td></tr></table></figure>
<p>在服务器端，在Java类中三个状态之间的转换。</p>
<p>1 json文本<br>2 json对象/数组<br>3 java对象/集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</div><div class="line"><span class="keyword">import</span> net.sf.json.JSONObject;</div><div class="line"><span class="keyword">import</span> net.sf.json.JsonConfig;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.domain.Goods;</div><div class="line"><span class="keyword">import</span> com.domain.Stu;</div><div class="line"><span class="keyword">import</span> com.domain.Types;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONTest</span> </span>&#123;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java对象。</span></div><div class="line">		Stu stu = <span class="keyword">new</span> Stu(<span class="number">1</span>,<span class="string">"peter"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//先将java对象转换成json对象</span></div><div class="line">		JSONObject jsonobj = JSONObject.fromObject(stu);</div><div class="line">		</div><div class="line">		<span class="comment">//将json对象转换成json文本。</span></div><div class="line">		String jsontxt = jsonobj.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsontxt);</div><div class="line">		<span class="comment">//将json文本转换成json对象</span></div><div class="line">		JSONObject jsono = JSONObject.fromObject(jsontxt);</div><div class="line">		<span class="comment">//将json对象转换成java对象</span></div><div class="line">		Stu s = (Stu) (JSONObject.toBean(jsono, Stu.class));</div><div class="line">		</div><div class="line">		System.out.println(s.getName());</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java集合。</span></div><div class="line">		Stu stu1 = <span class="keyword">new</span> Stu(<span class="number">1</span>,<span class="string">"peter1"</span>);</div><div class="line">		Stu stu2 = <span class="keyword">new</span> Stu(<span class="number">2</span>,<span class="string">"peter2"</span>);</div><div class="line">		Stu stu3 = <span class="keyword">new</span> Stu(<span class="number">3</span>,<span class="string">"peter3"</span>);</div><div class="line">		List&lt;Stu&gt; stuList = <span class="keyword">new</span> ArrayList&lt;Stu&gt;();</div><div class="line">		stuList.add(stu1);</div><div class="line">		stuList.add(stu2);</div><div class="line">		stuList.add(stu3);</div><div class="line">		</div><div class="line">		<span class="comment">//将java集合转换成json数组</span></div><div class="line">		JSONArray jsonArray = JSONArray.fromObject(stuList);</div><div class="line">		</div><div class="line">		<span class="comment">//将json数组转换成json文本</span></div><div class="line">		String jsonArrayTxt = jsonArray.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsonArrayTxt);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java对象。</span></div><div class="line">		Types types = <span class="keyword">new</span> Types(<span class="number">1</span>, <span class="string">"手机"</span>);</div><div class="line">		Goods goods = <span class="keyword">new</span> Goods(<span class="number">1</span>, <span class="string">"iPhone 7"</span>, types);</div><div class="line">		</div><div class="line">		JSONObject jsonObject = JSONObject.fromObject(goods);</div><div class="line">		</div><div class="line">		String jsonObjectTxt = jsonObject.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsonObjectTxt);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Test</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//java对象。</span></div><div class="line">		Types types = <span class="keyword">new</span> Types(<span class="number">1</span>, <span class="string">"手机"</span>);</div><div class="line">		Goods goods = <span class="keyword">new</span> Goods(<span class="number">1</span>, <span class="string">"iPhone 7"</span>, types);</div><div class="line">		types.getGoodsSet().add(goods);</div><div class="line">		</div><div class="line">		<span class="comment">//使用jsonConfig对象配置转换。可以设置哪些属性表示，哪些属性不表示,在两个类双向的属性包含对方的时候使用。</span></div><div class="line">		JsonConfig jsonConfig = <span class="keyword">new</span> JsonConfig();</div><div class="line">      <span class="comment">//表示显示时候types里面的goodsset将不会显示，从而不会造成死循环</span></div><div class="line">		jsonConfig.setExcludes(<span class="keyword">new</span> String[]&#123;<span class="string">"goodsSet"</span>&#125;);</div><div class="line">		</div><div class="line">		JSONObject jsonObject = JSONObject.fromObject(goods,jsonConfig);</div><div class="line">		</div><div class="line">		String jsonObjectTxt = jsonObject.toString();</div><div class="line">		</div><div class="line">		System.out.println(jsonObjectTxt);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/json/">json</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/20/json/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-throwable" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/19/throwable/">throwable</a>
    </h1>
  

        <a href="/2016/12/19/throwable/" class="archive-article-date">
  	<time datetime="2016-12-19T06:19:42.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-19</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="\images\throwable.jpg" alt="throwable"></p>
<p>  转：</p>
<p><a href="http://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/6155636</a></p>
<p>Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p> Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
<p>。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p>
<p> Exception（异常）:是程序本身可以处理的异常。</p>
<p> Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p>
<p>  在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。</p>
<p> 抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p>
<p> 捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
<p> 对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。</p>
<p>​    由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</p>
<p>  对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</p>
<p>  对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</p>
<p>   能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</p>
<p>​    任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的throw语句抛出异常。</p>
<p> 从方法中抛出的任何异常都必须使用throws子句。</p>
<p> 捕捉异常通过try-catch语句或者try-catch-finally语句实现。</p>
<p>  总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。</p>
<h5 id="Java常见异常"><a href="#Java常见异常" class="headerlink" title="Java常见异常"></a>Java常见异常</h5><p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p>
<ol>
<li>runtimeException子类:<br> 1、 java.lang.ArrayIndexOutOfBoundsException<br> 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br> 2、java.lang.ArithmeticException<br> 算术条件异常。譬如：整数除零等。<br> 3、java.lang.NullPointerException<br> 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br> 4、java.lang.ClassNotFoundException<br> 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。<br>5、java.lang.NegativeArraySizeException  数组长度为负异常<br>6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常<br>7、java.lang.SecurityException 安全性异常<br>8、java.lang.IllegalArgumentException 非法参数异常<br>2.IOException<br>IOException：操作输入流和输出流时可能出现的异常。<br>EOFException   文件已结束异常<br>FileNotFoundException   文件未找到异常</li>
<li>其他<br>ClassCastException    类型转换异常类<br>ArrayStoreException  数组中包含不兼容的值抛出的异常<br>SQLException   操作数据库异常类<br>NoSuchFieldException   字段未找到异常<br>NoSuchMethodException   方法未找到抛出的异常<br>NumberFormatException    字符串转换为数字抛出的异常<br>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常<br>IllegalAccessException  不允许访问某类异常<br>InstantiationException  当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li>
</ol>
<p>抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常。下面它们之间的异同。</p>
<p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常。</p>
<p>throw是语句抛出一个异常。</p>
<p>throws是方法可能抛出异常的声明。</p>
<p><strong>throw与throws的比较</strong></p>
<p>1、throws出现在方法函数头；而throw出现在函数体。<br>2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。<br>3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/throwable/">throwable</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/19/throwable/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-jspservlet" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/18/jspservlet/">jsp servlet（基础整理）</a>
    </h1>
  

        <a href="/2016/12/18/jspservlet/" class="archive-article-date">
  	<time datetime="2016-12-18T15:12:50.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-18</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="JSP-HTML-JAVA"><a href="#JSP-HTML-JAVA" class="headerlink" title="JSP = HTML + JAVA"></a>JSP = HTML + JAVA</h5><p>JSP页面的运行环境—JSP服务器，JSP容器</p>
<p>TOMCAT是一个JSP页面的运行环境的程序。WEB应用服务器。</p>
<p>作用是向浏览器输出。 格式： &lt;%=  表达式内容 %&gt;  注意：表达式的最后没有“;”</p>
<p>脚本 &lt;%  %&gt; 在HTML页面中嵌入JAVA代码的区域。可以访问后台的JAVA类。调用业务方法。</p>
<p>B/S 浏览器/服务器模型。</p>
<p>C/S 客户端/服务器模型。</p>
<p>Client/Server是建立在局域网的基础上的。Browser/Server是建立在广域网的基础上的.。<br>　　1．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的， 不必是专门的网络硬件环境。例如电话上网,，租用设备.，信息管理，有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。<br>　　2．对安全要求不同：C/S 一般面向相对固定的用户群， 对信息安全的控制能力很强， 一般高度机密的信息系统采用C/S 结构适宜，可以通过B/S发布部分可公开信息。B/S 建立在广域网之上, 对安全的控制能力相对弱，面向是不可知的用户群。<br>　　3．对程序架构不同：C/S 程序可以更加注重流程,，可以对权限多层次校验,，对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑,，建立在需要更加优化的基础之上，比C/S有更高的要求。 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统.。SUN 和IBM推的JavaBean 构件技术等，使 B/S更加成熟。<br>　　4．软件重用不同：C/S 程序可以不可避免的整体性考虑，构件的重用性不如在B/S要求下的构件的重用性好。B/S 对的多重结构,要求构件相对独立的功能，能够相对较好的重用。<br>　　5．系统维护不同：系统维护在是软件生存周期中，开销大。重要C/S 程序由于整体性,，必须整体考察， 处理出现的问题以及系统升级。升级难，可能是再做一个全新的系统。B/S程序由构件组成，方便构件个别的更换，实现系统的无缝升级，系统维护开销减到最小，用户从网上自己下载安装就可以实现升级。<br>　　6．处理问题不同：C/S 程序可以处理用户面固定，并且在相同区域,，安全要求高需求，与操作系统相关，应该都是相同的系统。B/S 建立在广域网上，面向不同的用户群，分散地域，这是C/S无法作到的，与操作系统平台关系最小。<br>　　7．用户接口不同：C/S 多是建立的Window平台上，表现方法有限。对程序员普遍要求较高。B/S 建立在浏览器上,，有更加丰富和生动的表现方式与用户交流，并且大部分难度减低，减低开发成本。<br>　　8．信息流不同：C/S 程序一般是典型的中央集权的机械式处理，交互性相对低。B/S 信息流向可变化， B-B、 B-C、 B-G等信息流向的变化，更象交易中心。</p>
<p>B/S 特点集中部署—-所有内容都在服务器-基于请求/响应方式进行浏览器与服务器之间的交互—–两个H。</p>
<p>HTTP：请求与响应的协议，规定标准。<br>HTML：响应的内容就只是HTML。因为IE只认识HTML。</p>
<h5 id="JSP页面隐式对象"><a href="#JSP页面隐式对象" class="headerlink" title="JSP页面隐式对象"></a>JSP页面隐式对象</h5><p>详解戳</p>
<p>[]: <a href="http://blog.csdn.net/sona_shi555/article/details/7797068" target="_blank" rel="external">http://blog.csdn.net/sona_shi555/article/details/7797068</a>    “JSP九大内置对象的作用和用法总结”</p>
<p>对于HTTP中get和post区别</p>
<p>详情有两篇博文</p>
<p><a href="http://blog.csdn.net/yipiankongbai/article/details/24025633" target="_blank" rel="external">http://blog.csdn.net/yipiankongbai/article/details/24025633</a></p>
<p>和<a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml" target="_blank" rel="external">http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml</a></p>
<h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>现在开一个Servlet要</p>
<pre><code>1继承HttpServlet

2重写doGet或doPost方法
</code></pre><p>1、doGet()针对get请求方式。</p>
<p>doPost()针对Post请求方式。</p>
<p>2、Servlet接口中没有doGet()和doPost()方法的。只有一个service()方法。</p>
<p>Service()方法是服务方法，用户发送一次请，就调用一次Service（）方法。</p>
<p>3、 在HttpServlet中将Service方法给出的实现，转换成了调用相应的doGet和doPost方法。</p>
<h5 id="转发重定向区别："><a href="#转发重定向区别：" class="headerlink" title="转发重定向区别："></a>转发重定向区别：</h5><p>重定向和转发有一个重要的不同：当使用转发时，JSP容器将使用一个内部的方法来调用目标页面，新的页面继续处理同一个请求，而浏览器将不会知道这个过程。 与之相反，重定向方式的含义是第一个页面通知浏览器发送一个新的页面请求。因为，当你使用重定向时，浏览器中所显示的URL会变成新页面的URL, 而当使用转发时，该URL会保持不变。重定向的速度比转发慢，因为浏览器还得发出一个新的请求。同时，由于重定向方式产生了一个新的请求，所以经过一次重定向后，request内的对象将无法使用。</p>
<p>​          怎么选择是重定向还是转发呢？通常情况下转发更快，而且能保持request内的对象，所以他是第一选择。但是由于在转发之后，浏览器中URL仍然指向开始页面，此时如果重载当前页面，开始页面将会被重新调用。如果你不想看到这样的情况，则选择转发。 </p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jsp-servlet/">jsp servlet</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/18/jspservlet/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-threadlocal" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/14/threadlocal/">threadlocal</a>
    </h1>
  

        <a href="/2016/12/14/threadlocal/" class="archive-article-date">
  	<time datetime="2016-12-14T11:00:35.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-14</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> ThreadLocal是解决线程安全问题一个很好的思路，ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本，由于Key值不可重复，每一个“线程对象”对应线程的“变量副本”，而到达了线程安全。</p>
<p>Spring通过各种DAO模板类降低了开发者使用各种数据持久技术的难度。这些模板类都是线程安全的，也就是说，多个DAO可以复用同一个模板实例而不会发生冲突。</p>
<p>我们使用模板类访问底层数据，根据持久化技术的不同，模板类需要绑定数据连接或会话的资源。但这些资源本身是非线程安全的，也就是说它们不能在同一时刻被多个线程共享。</p>
<p>虽然模板类通过资源池获取数据连接或会话，但资源池本身解决的是数据连接或会话的缓存问题，并非数据连接或会话的线程安全问题。</p>
<p>按照传统经验，如果某个对象是非线程安全的，在多线程环境下，对对象的访问必须采用synchronized进行线程同步。但Spring的DAO模板类并未采用线程同步机制，因为线程同步限制了并发访问，会带来很大的性能损失。</p>
<h5 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h5><p>早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p>
<p>ThreadLocal很容易让人望文生义，想当然地认为是一个“本地线程”。其实，ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。</p>
<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。</p>
<p>线程局部变量并不是Java的新发明，很多语言（如IBM IBM XL FORTRAN）在语法层面就提供线程局部变量。在Java中没有提供在语言级支持，而是变相地通过ThreadLocal的类提供支持。</p>
<p>所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。</p>
<p><strong>ThreadLocal的接口方法</strong></p>
<p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p>
<p>· void set(Object value) </p>
<p>设置当前线程的线程局部变量的值。</p>
<p>· public Object get() </p>
<p>该方法返回当前线程所对应的线程局部变量。</p>
<p>· public void remove() </p>
<p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p>
<p>· protected Object initialValue() </p>
<p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
<p>值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</p>
<p>ThreadLocal**是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">SimpleThreadLocal</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadLocal</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Map valueMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object newValue)</span> </span>&#123;</div><div class="line"></div><div class="line">		valueMap.put(Thread.currentThread(), newValue);</div><div class="line">  		①**键为线程对象，值为本线程的变量副本**</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	Thread currentThread = Thread.currentThread();</div><div class="line"></div><div class="line">		Object o = valueMap.get(currentThread);</div><div class="line">  		②**返回本线程对应的变量**</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (o == <span class="keyword">null</span> &amp;&amp; !valueMap.containsKey(currentThread)) &#123;</div><div class="line">      ③**如果在Map中不存在，放到Map**中保存起来。</div><div class="line"></div><div class="line">	o = initialValue();</div><div class="line"></div><div class="line">	valueMap.put(currentThread, o);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> o;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	valueMap.remove(Thread.currentThread());</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这个ThreadLocal实现版本显得比较幼稚，但它和JDK所提供的ThreadLocal类在实现思路上是相近的。</p>
<p>一个具体的实例了解一下ThreadLocal的具体使用方法。</p>
<p> SequenceNumber</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.baobaotao.basic;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceNumber</span> </span>&#123;</div><div class="line"></div><div class="line">①**通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值**</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal seqNum = <span class="keyword">new</span> ThreadLocal()&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">②**获取下一个序列值**</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	seqNum.set(seqNum.get()+<span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> seqNum.get();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">	SequenceNumber sn = <span class="keyword">new</span> SequenceNumber();</div><div class="line"></div><div class="line">	③ <span class="number">3</span>**个线程共享sn，各自产生序列号**</div><div class="line"></div><div class="line">	TestClient t1 = <span class="keyword">new</span> TestClient(sn);</div><div class="line"></div><div class="line">	TestClient t2 = <span class="keyword">new</span> TestClient(sn);</div><div class="line"></div><div class="line">	TestClient t3 = <span class="keyword">new</span> TestClient(sn);</div><div class="line"></div><div class="line">	t1.start();</div><div class="line">	</div><div class="line">	t2.start();</div><div class="line"></div><div class="line">	t3.start();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> SequenceNumber sn;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClient</span><span class="params">(SequenceNumber sn)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.sn = sn;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;④**每个线程打出<span class="number">3</span>个序列值**</div><div class="line"></div><div class="line">System.out.println(<span class="string">"thread["</span>+Thread.currentThread().getName()+</div><div class="line"></div><div class="line"><span class="string">"] sn["</span>+sn.getNextNum()+<span class="string">"]"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个SequenceNumber实例。运行以上代码，在控制台上输出以下的结果：</p>
<p><strong>thread[Thread-2] sn[1]</strong></p>
<p><strong>thread[Thread-0] sn[1]</strong></p>
<p><strong>thread[Thread-1] sn[1]</strong></p>
<p><strong>thread[Thread-2] sn[2]</strong></p>
<p><strong>thread[Thread-0] sn[2]</strong></p>
<p><strong>thread[Thread-1] sn[2]</strong></p>
<p><strong>thread[Thread-2] sn[3]</strong></p>
<p><strong>thread[Thread-0] sn[3]</strong></p>
<p><strong>thread[Thread-1] sn[3]</strong></p>
<p>考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个SequenceNumber实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。</p>
<p>Thread同步机制的比较</p>
<p>ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
<p>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<p>当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal，这将极大地简化你的程序，使程序更加易读、简洁。</p>
<p>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal版本。</p>
<p>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<p>Spring使用ThreadLocal解决线程安全问题</p>
<p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolderTransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</p>
<p>一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程</p>
<p>这样你就可以根据需要，将一些非线程安全的变量以ThreadLocal存放，在同一次请求响应的调用线程中，所有关联的对象引用到的都是同一个变量。</p>
<p>下面的实例能够体现Spring对有状态Bean的改造思路：</p>
<p>代码清单3 TopicDao：非线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDao</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Connection conn;①**一个非线程安全的变量**</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">			Statement stat = conn.createStatement();</div><div class="line">    	  ②**引用非线程安全变量**        </div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造：</p>
<p> TopicDao：线程安全</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDao</span> </span>&#123;</div><div class="line"></div><div class="line">①**使用ThreadLocal保存Connection变量**</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal connThreadLocal = <span class="keyword">new</span> ThreadLocal();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	②**如果connThreadLocal没有本线程对应的Connection创建一个新的	Connection，**并将其保存到线程本地变量中。</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (connThreadLocal.get() == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">	Connection conn = ConnectionManager.getConnection();</div><div class="line"></div><div class="line">	connThreadLocal.set(conn);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> conn;</div><div class="line"></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> connThreadLocal.get();③**直接返回线程本地变量**</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	④**从ThreadLocal中获取线程对应的Connection**</div><div class="line"></div><div class="line">	Statement stat = getConnection().createStatement();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不同的线程在使用TopicDao时，先判断connThreadLocal.get()是否是null，如果是null，则说明当前线程还没有对应的Connection对象，这时创建一个Connection对象并添加到本地线程变量中；如果不为null，则说明当前的线程已经拥有了Connection对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的Connection，而不会使用其它线程的Connection。因此，这个TopicDao就可以做到singleton共享了。</p>
<p>当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在DAO只能做到本DAO的多个方法共享Connection时不发生线程安全问题，但无法和其它DAO共用同一个Connection，要做到同一事务多DAO共享同一Connection，必须在一个共同的外部类使用ThreadLocal保存Connection。但这个实例基本上说明了Spring对有状态类线程安全化的解决思路。</p>
<p>小结</p>
<p>ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/14/threadlocal/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-JDBC" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/JDBC/">JDBC（基础整理）</a>
    </h1>
  

        <a href="/2016/12/11/JDBC/" class="archive-article-date">
  	<time datetime="2016-12-11T07:00:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java Database Connection:java数据库连接技术。</p>
<p>查看详情</p>
<p>四种连接方式（只写两种）：</p>
<p>1 桥连： JDBC-ODBC连接。</p>
<p> 2 直连： 直接通过JDBC驱动连接数据库。</p>
<h5 id="JDBC中的核心接口与类"><a href="#JDBC中的核心接口与类" class="headerlink" title="JDBC中的核心接口与类"></a>JDBC中的核心接口与类</h5><h6 id="三个核心接口"><a href="#三个核心接口" class="headerlink" title="三个核心接口"></a>三个核心接口</h6><p>Connection接口：连接数据库接口。负责与数据库之间的连接。</p>
<p>Statement接口：操作数据库接口，常用的子接口PreparedStatement接口，预处理SQL语句。负责执行CRUD命令。</p>
<p>​   获得Statement对象  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Statement stat = conn.createStatement();</div></pre></td></tr></table></figure>
<p>​ 执行查询的方法：</p>
<pre><code>ResultSet rs = stat.executeQuery(SQL);
</code></pre><p>执行增删改的方法:</p>
<p>​    int i = stat.executeUpdate(SQL);</p>
<p>ResultSet接口：结果集接口。负责接收查询的结果。</p>
<p>结果集对象下移一条时调用方法 next();</p>
<p>​          两个值：BOF , EOF</p>
<p>​        BOF：第一行的前面。rs对象一开始指向的位置就是BOF。</p>
<p>​        EOF：最后一行的后面。rs对象的next方法是下移一行，如果移动之  后指向了EOF返回false，表示没有记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.ResultSet;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//连接数据库的四大参数项</span></div><div class="line">		String username = <span class="string">"scott"</span>;</div><div class="line">		String password = <span class="string">"tiger"</span>;</div><div class="line">		String driver_class=<span class="string">"oracle.jdbc.driver.OracleDriver"</span>;<span class="comment">//驱动类名称</span></div><div class="line">		String url = <span class="string">"jdbc:oracle:thin:@localhost:1521:XE"</span>;<span class="comment">//连接字符串</span></div><div class="line"><span class="comment">//		1、加载JDBC的驱动-连接哪个数据库产品就加载哪个数据库的JDBC驱动</span></div><div class="line">		Class.forName(driver_class);</div><div class="line"><span class="comment">//		2、创建与数据库之间的连接</span></div><div class="line">		Connection conn = DriverManager.getConnection(url, username	, password);</div><div class="line"><span class="comment">//		3、执行CRUD命令</span></div><div class="line">		String sql = <span class="string">"select * from emp"</span>;</div><div class="line">		Statement stat = conn.createStatement();</div><div class="line"><span class="comment">//		4、如果是查询就处理结果集</span></div><div class="line">		ResultSet rs = stat.executeQuery(sql);</div><div class="line">		<span class="comment">//rs是结果集对象，结果集就是一个二维表格。</span></div><div class="line">		<span class="keyword">while</span>(rs.next())&#123;<span class="comment">//下一行。如果返回true说明有记录。</span></div><div class="line">			<span class="keyword">int</span> empno = rs.getInt(<span class="number">1</span>);</div><div class="line">			String ename = rs.getString(<span class="string">"ename"</span>);</div><div class="line">			Date date = rs.getDate(<span class="string">"hiredate"</span>);</div><div class="line">			System.out.println(empno+<span class="string">":"</span>+ename+<span class="string">":"</span>+date);</div><div class="line">		&#125;</div><div class="line"><span class="comment">//		5、关闭连接，释放资源</span></div><div class="line">		rs.close();</div><div class="line">		stat.close();</div><div class="line">		conn.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对数据库进行增删改操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.ResultSet;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">//连接数据库的四大参数项</span></div><div class="line">		String username = <span class="string">"scott"</span>;</div><div class="line">		String password = <span class="string">"tiger"</span>;</div><div class="line">		String driver_class=<span class="string">"oracle.jdbc.driver.OracleDriver"</span>;<span class="comment">//驱动类名称</span></div><div class="line">		String url = <span class="string">"jdbc:oracle:thin:@localhost:1521:XE"</span>;<span class="comment">//连接字符串</span></div><div class="line"><span class="comment">//		1、加载JDBC的驱动-连接哪个数据库产品就加载哪个数据库的JDBC驱动</span></div><div class="line">		Class.forName(driver_class);</div><div class="line"><span class="comment">//		2、创建与数据库之间的连接</span></div><div class="line">		Connection conn = DriverManager.getConnection(url, username	, password);</div><div class="line">		System.out.println(conn);</div><div class="line"><span class="comment">//		3、执行CRUD命令</span></div><div class="line">		String sql = <span class="string">"insert into dept(deptno,dname,loc) values(50 , '总部' ,'北京远洋')"</span>;</div><div class="line">		Statement stat = conn.createStatement();</div><div class="line">		<span class="keyword">int</span> count = stat.executeUpdate(sql);<span class="comment">//增删改都调用这个方法</span></div><div class="line">		<span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"操作成功！"</span>);</div><div class="line">		&#125;</div><div class="line"><span class="comment">//		7.5、关闭连接，释放资源</span></div><div class="line">		stat.close();</div><div class="line">		conn.close();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PreparedStatement接口：Statement子接口，预处理SQL语句。</p>
<h5 id="创建PreparedStatement接口的实例"><a href="#创建PreparedStatement接口的实例" class="headerlink" title="创建PreparedStatement接口的实例"></a>创建PreparedStatement接口的实例</h5><p>String sql = “insert into dept(deptno,dname,loc) values(?,?,?)”;//可以使用?占位符</p>
<p>PreparedStatementpstat = conn.prepareStatement(sql);</p>
<p>//为占位符赋值</p>
<p>pstat.setInt(1, deptno);</p>
<p>pstat.setString(2, dname);</p>
<p>pstat.setString(3, loc);</p>
<p>执行</p>
<p>pstat.executeUpdate();</p>
<h3 id="数据库连接池技术"><a href="#数据库连接池技术" class="headerlink" title="数据库连接池技术"></a>数据库连接池技术</h3><h6 id="世面上主流有-DBCP-C3P0"><a href="#世面上主流有-DBCP-C3P0" class="headerlink" title="世面上主流有:DBCP , C3P0"></a>世面上主流有:DBCP , C3P0</h6><h5 id="使用DBCP创建数据库连接对象"><a href="#使用DBCP创建数据库连接对象" class="headerlink" title="使用DBCP创建数据库连接对象"></a>使用DBCP创建数据库连接对象</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="\images\DBCP.png" alt="DBCP"></h5><h5 id="设置DBCP连接池参数"><a href="#设置DBCP连接池参数" class="headerlink" title="设置DBCP连接池参数"></a>设置DBCP连接池参数</h5><p> 创建一个资源文件.properteis。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">driverClassName=oracle.jdbc.driver.OracleDriver  url=jdbc:oracle:thin:<span class="meta">@localhost</span>:<span class="number">1521</span>:XE </div><div class="line"></div><div class="line">username=scott</div><div class="line"></div><div class="line">  password=tiger</div><div class="line"></div><div class="line">  maxActive=<span class="number">50</span>--最大活动数量</div><div class="line"></div><div class="line">  maxIdle=<span class="number">20</span> </div><div class="line"></div><div class="line">  --最大空闲数量</div><div class="line"></div><div class="line">  maxWait=<span class="number">60000</span> --最大等待时间，毫秒。</div></pre></td></tr></table></figure>
<p>## </p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JDBC/">JDBC</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/JDBC/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-java-API" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/java-API/">java collection接口（基础整理）</a>
    </h1>
  

        <a href="/2016/12/11/java-API/" class="archive-article-date">
  	<time datetime="2016-12-11T02:49:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="集合的整体的框架结构"><a href="#集合的整体的框架结构" class="headerlink" title="集合的整体的框架结构"></a>集合的整体的框架结构</h5><p>转自</p>
<p><a href="http://blog.csdn.net/softwave/article/details/4166598" target="_blank" rel="external">http://blog.csdn.net/softwave/article/details/4166598</a></p>
<p><img src="\images\collection.png" alt="collection"></p>
<p>在整个集合框架中顶层的接口：Collection接口。</p>
<p> 在Collection接口下有两个子接口List 和Set</p>
<p> 在整个集合框架中还有一个接口Map</p>
<p>Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap</p>
<p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）<br>　　所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个 Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后 一个构造函数允许用户复制一个Collection。<br>　　如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：<br>　　　　Iterator it = collection.iterator(); // 获得一个迭代子<br>　　　　while(it.hasNext()) {<br>　　　　　　Object obj = it.next(); // 得到下一个元素<br>　　　　}<br>　　由Collection接口派生的两个接口是List和Set。</p>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><strong>List接口</strong></h4><p>　　List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。<br>和下面要提到的Set不同，List允许有相同的元素。<br>　　除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素， 还能向前或向后遍历。<br>　　实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p>
<p><strong>LinkedList类</strong><br>　　LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。<br>　　注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<br>　　List list = Collections.synchronizedList(new LinkedList(…));</p>
<p><strong>ArrayList类</strong>　　</p>
<p>​     ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。</p>
<p>size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。</p>
<p>　　每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">算法</a> 并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。<br>　　和LinkedList一样，ArrayList也是非同步的（unsynchronized）。</p>
<p><strong>Vector类</strong>　　</p>
<p>​     Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和 ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了 Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。</p>
<p><strong>Stack 类</strong><br>　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口　"></a><strong>Set接口</strong>　</h4><p>　Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。<br>　　很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。<br>　　请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p>
<h5 id="hashset类"><a href="#hashset类" class="headerlink" title="hashset类"></a>hashset类</h5><p>HashSet 的实现其实非常简单，它只是封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。 </p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><strong>Map接口</strong></h4><p>　　Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p>
<h5 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="　Hashtable类"></a>　<strong>Hashtable类</strong></h5><p>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。<br>　　添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。</p>
<p>使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”：<br>　　　　Hashtable numbers = new Hashtable();<br>　　　　numbers.put(“one”, new Integer(1));<br>　　　　numbers.put(“two”, new Integer(2));<br>　　　　numbers.put(“three”, new Integer(3));<br>　　要取出一个数，比如2，用相应的key：<br>　　　　Integer n = (Integer)numbers.get(“two”);</p>
<p>由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方 法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相 同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如 果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希 表的操作。<br>　　如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。<br>　　Hashtable是同步的。</p>
<p><strong>HashMap类</strong></p>
<p>hashmap源码详细讲解<a href="http://www.cnblogs.com/ITtangtang/p/3948406.html" target="_blank" rel="external">http://www.cnblogs.com/ITtangtang/p/3948406.html</a></p>
<p>　　HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例</p>
<p><strong>总结</strong>　　如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。<br>　　如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。<br>　　<strong>要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</strong><br>　　尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</p>
<h4 id="相互区别"><a href="#相互区别" class="headerlink" title="相互区别"></a><strong>相互区别</strong></h4><p><strong>Vector和ArrayList</strong></p>
<p>1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用</p>
<p>arraylist效率比较高。<br>2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度</p>
<p>的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。<br>3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而</p>
<p>如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据</p>
<p>所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。</p>
<p>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要 差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</p>
<p><strong>arraylist和linkedlist</strong></p>
<p>1.ArrayList是实现了基于动态数组的<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="external">数据结构</a>，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>    这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数 据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p>
<p><strong>HashMap与TreeMap</strong>        (注)<br>       文章出处：<a href="http://www.diybl.com/course/3_program/java/javaxl/200875/130233.html" target="_blank" rel="external">http://www.diybl.com/course/3_program/java/javaxl/200875/130233.html</a><br>       1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</p>
<p>2, 、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。　　这个TreeMap没有调优选项，因为该树总处于平衡状态。</p>
<p><strong>hashtable与hashmap</strong></p>
<p>一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现</p>
<p>二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的</p>
<p>三.值：只有HashMap可以让你将空值作为一个表的条目的key或value</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/API/">API</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/java-API/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-java-oop" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/java-oop/">java oop（基础整理）</a>
    </h1>
  

        <a href="/2016/12/11/java-oop/" class="archive-article-date">
  	<time datetime="2016-12-11T01:58:25.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="JavaBean规范"><a href="#JavaBean规范" class="headerlink" title="JavaBean规范"></a>JavaBean规范</h5><pre><code>1 类一定要有默认构造方法。

2 属性要private。

3 通过public的方法来操作属性。
</code></pre><h5 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h5><h5 id="可以修饰三个对象"><a href="#可以修饰三个对象" class="headerlink" title="可以修饰三个对象"></a>可以修饰三个对象</h5><pre><code> 1 变量：局部变量，常量，值不可改变。

    类中的属性：

       1 属性可以初始化，但不能通过set方法赋值。

       2 属性的初始化一定要使用类的构造方法，所以默认构造方法不可     用。

    基本数据类型：值不可改变。

    引用数据类型：引用不可改变。

2方法：方法不可改变。方法不能被重写。

3类：类不可改变。类不能被继承。
</code></pre><h5 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h5><pre><code>叫静态修饰符。

1 代码块：静态代码块，静态块。

   代码块：{  }

   静态代码块：static{ }

   给静态属性初始化用的。

2 属性：静态属性

   没加的static的属性叫实例属性。是实例的。

   加了static叫静态属性，也叫类属性。是类的。
</code></pre><p>静态方法只可以访问静态属性和静态方法。</p>
<h1 id="abstract修饰符"><a href="#abstract修饰符" class="headerlink" title="abstract修饰符"></a>abstract修饰符</h1><pre><code>Abstract中文叫抽象。

可以修饰二个地方：方法和类。
</code></pre><h2 id="6-1-抽象方法："><a href="#6-1-抽象方法：" class="headerlink" title="6.1 抽象方法："></a>6.1 抽象方法：</h2><pre><code>使用abstract修饰符修饰的方法。

抽象方法有自己的固定格式：没有方法体。
</code></pre><h5 id="抽象类："><a href="#抽象类：" class="headerlink" title="抽象类："></a>抽象类：</h5><pre><code>类前面加abstract修饰符的类,叫抽象类。

一个类中如果有抽象方法，这个类必须是抽象类。

在一个抽象类中可以有属性，方法，抽象方法，但也可不存在抽象方法。

抽象类不能被实例化。

抽象类在使用时一定要做为父类，让子类继承，重写抽象方法。
</code></pre><h5 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h5><p>1 公有静态常量，publicstatic final</p>
<p> 2 公有抽象方法，抽象方法的修饰符abstract。但是在接口中只能有抽象方法，在接口可以省略abstract</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>1 不能被new，实例化。</p>
<p>2 一定要找一个类，去实现接口。关键字implements</p>
<p> 在实现类中一定要对接口中声明的抽象方法给出具体的实现。重写接口中的抽象方法。</p>
<pre><code>4 当实现类中不能将接口中所有的抽象方法全部给出实现时，这个实现类就必须是抽象类。

5 接口同样支持面向对象的多态这个特性。

   接口类型的引用可以指向一个其实现类的实例。

   接口类型  接口类型引用 = new 实现类（）;

6 一个类只能继承自一个父类。Extends 类 只能有一个。Java是一种单继承的语言。

7 一个类可以实现多个接口。Implements 接口1，接口2

8 一个类可以同时继承一个父类，再同时实现多个接口。
</code></pre><h5 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h5><p>在实例内部代表实例本身的一个引用。一般在参数名称与属性名称一致时，用来区分哪个是属性用的。在属性前面加上”this.”</p>
<p>this关键字在实例内部可以调用三个内容：</p>
<pre><code>1属性：调用实例本身自己的属性。

    this.属性名

2方法：调用实例本身自己的方法。

    this.方法名（）;

3构造方法：调用实例本身自己的构造方法。

    this();

    只能写在构造方法中。

    只能写在构造方法的第一行
</code></pre><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>构造方法是一个特殊的方法。</p>
<pre><code>1 方法名称必须与类名一致。完全一致。大小写都要一致。

2 方法没有返回类型说明。注意不是没有返回值，是没有返回类型的说明。
</code></pre><p>构造方法是在new时（实例化），由系统自动调用的方法。（在实例化一个类的对象的过程中一同类同名不同参：</p>
<p>在一个类中有多个同名的方法，但是方法的参数不同时，把这几个同名的方法叫方法重载。</p>
<pre><code>参数不同包含：

   1参数个数。

   2参数类型。



构造方法也是方法，所以构造方法也可以重载。定要调用构造方法） 构造方法的作用是用来构造实例并初始化属性。
</code></pre><p><strong>方法重载</strong></p>
<p>同类同名不同参：</p>
<p>在一个类中有多个同名的方法，但是方法的参数不同时，把这几个同名的方法叫方法重载。</p>
<pre><code>参数不同包含
</code></pre><p>​       1参数个数。</p>
<pre><code>   2参数类型。

构造方法也是方法，所以构造方法也可以重载。
</code></pre><h5 id="面向对象的三大特性-封装，继承，多态"><a href="#面向对象的三大特性-封装，继承，多态" class="headerlink" title="面向对象的三大特性-封装，继承，多态"></a>面向对象的三大特性-封装，继承，多态</h5><p>封装的目的是为了实现模块化开发。</p>
<p> 具体体现方式：封装的目的是为了获得类和方法。</p>
<h6 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h6><p>private : 私有，只能类内使用。子类不能访问。</p>
<p>（default）：默认，包级别，本类和同包可用。</p>
<p>   protected：保护，同包和子类。</p>
<p>   public ： 公有，任何位置都可以访问</p>
<h5 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h5><pre><code>子类可以复用父类中的属性和方法。（必须参考访问修饰符，如果属性或方法是以private修饰时，在子类中不能使用父类的方法了。）继承不是单纯的代码复制。会为这个子类在创建子类实例时同时也创建一个属于这个子类实例的父类实例。  Java会为每个子类实例都关联一个父类实例。
</code></pre><h5 id="方法重写-Override"><a href="#方法重写-Override" class="headerlink" title="方法重写(Override)"></a>方法重写(Override)</h5><p>两个类要有继承关系。  在子类重新编写相同的方法。方法名称，返回类型，参数都必须相同。 我们就叫方法重写</p>
<h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a><strong>super关键字</strong></h5><p>在实例内部引用其父类实例的一个引用。使用super关键字可以调用父类的属性和方法。</p>
<pre><code>关于super常见的用法 

   1super.父类方法（）;   调用父类的方法。一般在子类重写的方法中调用父类的方法。
</code></pre><p>​       2 super（）;               调用父类的构造方法。只能在子类的构造方法的第一行出现。用来明确指定调用父类的哪个构造方法。</p>
<p>在没有多态时，使用继承的目的是为了代码复用。</p>
<pre><code>在没有多态时，使用继承的目的是为了修改现有类，创建新类。
</code></pre><h5 id="多态（是面向对象语言的最核心的特性）"><a href="#多态（是面向对象语言的最核心的特性）" class="headerlink" title="多态（是面向对象语言的最核心的特性）"></a>多态（是面向对象语言的最核心的特性）</h5><h6 id="多态的基础："><a href="#多态的基础：" class="headerlink" title="多态的基础："></a>多态的基础：</h6><pre><code> 1 要有继承：extends

2要有方法重写：在子类中重写父类继承的方法。声明一个与父类一样的方法。但是方法的内容可以重新写。
</code></pre><h2 id="多态的格式："><a href="#多态的格式：" class="headerlink" title="多态的格式："></a>多态的格式：</h2><pre><code>父类引用指向子类实例    父类类型 父类引用  = new 子类类型();
</code></pre><p>​     父类引用指向了一个子类的实例时，父类引用可以调用二类方法。</p>
<pre><code>1父类中声明的自己的方法。

2 子类中重写父类的方法。
</code></pre><h6 id="多态的一般使用方法的格式："><a href="#多态的一般使用方法的格式：" class="headerlink" title="多态的一般使用方法的格式："></a>多态的一般使用方法的格式：</h6><pre><code>1将父类引用做为方法的形参。

2将子类实例做为方法的实参。
</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaoop/">javaoop</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/java-oop/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-java1" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/11/java1/">java基础整理</a>
    </h1>
  

        <a href="/2016/12/11/java1/" class="archive-article-date">
  	<time datetime="2016-12-11T01:31:16.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-12-11</time>
</a>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h5><p>JAVA程序运行过程中，有一个线程叫垃圾回收线程。程序运行了一时间之后很多垃圾信息。回收。</p>
<pre><code>自动调用。程序员不能控制。1 内存不够。2 CPU空闲。

垃圾：没有被引用的内存空间。
</code></pre><h5 id="java运行机制"><a href="#java运行机制" class="headerlink" title="java运行机制"></a>java运行机制</h5><p>Java先编译后解释型语言。</p>
<pre><code>源文件(.java)----编译-&gt;类文件(.class)（字节码文件）---解释执行（JVM：java虚拟机）---&gt;机器指令
</code></pre><p>JDK(Java Development Kit) Java开发工具包 </p>
<p>   JDK = JRE + 工具（编译器、调试器、其他工具……） + 类库 </p>
<p>JRE (Java Runtime Environment)  Java运行时环境 </p>
<p>  JRE = JVM(Java Virtual Machine) Java虚拟机+解释器 </p>
<p><img src="\images\javamodel.png" alt="javamodel"></p>
<p>原始数据类型就只有8个：byte,short,int,long  </p>
<p>float,double  char   boolean</p>
<h5 id="String字符串数据类型"><a href="#String字符串数据类型" class="headerlink" title="String字符串数据类型"></a>String字符串数据类型</h5><p>String实际上它是一个类,</p>
<p>字符串不变性：表示字符串字面量是不会改变的。</p>
<p>字符串常量池。用来存放字符串常量</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组就是保存同一类型的一大堆的变量。</p>
<p>声明一个数组。   int[] a; 推荐使用。</p>
<p>数组的异常- ArrayIndexOutOfBoundsException（索引超出范围）</p>
<p><strong>数组是引用数据类型</strong></p>
<p>当一个数组给另一个数组，使用数组名称赋值时，实际上是将数组的引用交给另一个数组。</p>
<p>两个数组使用的是同一块内存，两个数组引用是相同的。</p>
<p>所以一个数组对数组元素的修改等于两个数组一起改变。</p>
<h6 id="java-util-Arrays类。封装了针对数组的操作方法。"><a href="#java-util-Arrays类。封装了针对数组的操作方法。" class="headerlink" title="java.util.Arrays类。封装了针对数组的操作方法。"></a>java.util.Arrays类。封装了针对数组的操作方法。</h6><p> sort。排序方法。sort(byte[] a)对指定的 byte 型数组按数字升序进行排序。</p>
<p>binarySearch(int[]a,int key)</p>
<pre><code>使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。 
</code></pre><p>参数： </p>
<pre><code>a - 要搜索的数组 

key - 要搜索的值 
</code></pre><p>返回： </p>
<pre><code>如果它包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。*插入点* 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 a.length。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。
</code></pre><p>copyOf使用老数组创建一个新的数组。同时拷贝数据。</p>
<h5 id="二维数组和多维数组"><a href="#二维数组和多维数组" class="headerlink" title="二维数组和多维数组"></a>二维数组和多维数组</h5><p>二维数组是否可以排序？不能，会报ClassCastException异常。</p>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>为什么要创建函数？</p>
<pre><code>一个函数代表了一个功能。功能最好单一，独立，不可拆分。

可以重复使用

调用方便

结构清晰，层次更明确，修改容易。

可以利用函数将多层的循环变成多个一层的循环。

为了给我们的程序分模块。
</code></pre><p>“</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/12/11/java1/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 caroltuan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js?v=4.0.0.js"></script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">三大框架 hibernate</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">learning</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">JDBC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">API</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">ajax</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">javaoop</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">jsp servlet</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">json</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">throwable</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)">多线程</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://shinerio.cc" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>自恋瑞的blog</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">一只团&lt;br&gt;&lt;br&gt;一只想要认真学习的团</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>