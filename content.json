[{"title":"jsp servlet（基础整理）","date":"2016-12-18T15:12:50.000Z","path":"2016/12/18/jspservlet/","text":"JSP = HTML + JAVAJSP页面的运行环境—JSP服务器，JSP容器 TOMCAT是一个JSP页面的运行环境的程序。WEB应用服务器。 作用是向浏览器输出。 格式： &lt;%= 表达式内容 %&gt; 注意：表达式的最后没有“;” 脚本 &lt;% %&gt; 在HTML页面中嵌入JAVA代码的区域。可以访问后台的JAVA类。调用业务方法。 B/S 浏览器/服务器模型。 C/S 客户端/服务器模型。 Client/Server是建立在局域网的基础上的。Browser/Server是建立在广域网的基础上的.。 1．硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的， 不必是专门的网络硬件环境。例如电话上网,，租用设备.，信息管理，有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。 2．对安全要求不同：C/S 一般面向相对固定的用户群， 对信息安全的控制能力很强， 一般高度机密的信息系统采用C/S 结构适宜，可以通过B/S发布部分可公开信息。B/S 建立在广域网之上, 对安全的控制能力相对弱，面向是不可知的用户群。 3．对程序架构不同：C/S 程序可以更加注重流程,，可以对权限多层次校验,，对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑,，建立在需要更加优化的基础之上，比C/S有更高的要求。 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统.。SUN 和IBM推的JavaBean 构件技术等，使 B/S更加成熟。 4．软件重用不同：C/S 程序可以不可避免的整体性考虑，构件的重用性不如在B/S要求下的构件的重用性好。B/S 对的多重结构,要求构件相对独立的功能，能够相对较好的重用。 5．系统维护不同：系统维护在是软件生存周期中，开销大。重要C/S 程序由于整体性,，必须整体考察， 处理出现的问题以及系统升级。升级难，可能是再做一个全新的系统。B/S程序由构件组成，方便构件个别的更换，实现系统的无缝升级，系统维护开销减到最小，用户从网上自己下载安装就可以实现升级。 6．处理问题不同：C/S 程序可以处理用户面固定，并且在相同区域,，安全要求高需求，与操作系统相关，应该都是相同的系统。B/S 建立在广域网上，面向不同的用户群，分散地域，这是C/S无法作到的，与操作系统平台关系最小。 7．用户接口不同：C/S 多是建立的Window平台上，表现方法有限。对程序员普遍要求较高。B/S 建立在浏览器上,，有更加丰富和生动的表现方式与用户交流，并且大部分难度减低，减低开发成本。 8．信息流不同：C/S 程序一般是典型的中央集权的机械式处理，交互性相对低。B/S 信息流向可变化， B-B、 B-C、 B-G等信息流向的变化，更象交易中心。 B/S 特点集中部署—-所有内容都在服务器-基于请求/响应方式进行浏览器与服务器之间的交互—–两个H。 HTTP：请求与响应的协议，规定标准。HTML：响应的内容就只是HTML。因为IE只认识HTML。 JSP页面隐式对象详解戳 []: http://blog.csdn.net/sona_shi555/article/details/7797068 “JSP九大内置对象的作用和用法总结” 对于HTTP中get和post区别 详情有两篇博文 http://blog.csdn.net/yipiankongbai/article/details/24025633 和http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml Servlet现在开一个Servlet要 1继承HttpServlet 2重写doGet或doPost方法 1、doGet()针对get请求方式。 doPost()针对Post请求方式。 2、Servlet接口中没有doGet()和doPost()方法的。只有一个service()方法。 Service()方法是服务方法，用户发送一次请，就调用一次Service（）方法。 3、 在HttpServlet中将Service方法给出的实现，转换成了调用相应的doGet和doPost方法。 转发重定向区别：重定向和转发有一个重要的不同：当使用转发时，JSP容器将使用一个内部的方法来调用目标页面，新的页面继续处理同一个请求，而浏览器将不会知道这个过程。 与之相反，重定向方式的含义是第一个页面通知浏览器发送一个新的页面请求。因为，当你使用重定向时，浏览器中所显示的URL会变成新页面的URL, 而当使用转发时，该URL会保持不变。重定向的速度比转发慢，因为浏览器还得发出一个新的请求。同时，由于重定向方式产生了一个新的请求，所以经过一次重定向后，request内的对象将无法使用。 ​ 怎么选择是重定向还是转发呢？通常情况下转发更快，而且能保持request内的对象，所以他是第一选择。但是由于在转发之后，浏览器中URL仍然指向开始页面，此时如果重载当前页面，开始页面将会被重新调用。如果你不想看到这样的情况，则选择转发。","tags":[{"name":"jsp servlet","slug":"jsp-servlet","permalink":"http://yoursite.com/tags/jsp-servlet/"}]},{"title":"threadlocal","date":"2016-12-14T11:00:35.000Z","path":"2016/12/14/threadlocal/","text":"ThreadLocal是解决线程安全问题一个很好的思路，ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本，由于Key值不可重复，每一个“线程对象”对应线程的“变量副本”，而到达了线程安全。 Spring通过各种DAO模板类降低了开发者使用各种数据持久技术的难度。这些模板类都是线程安全的，也就是说，多个DAO可以复用同一个模板实例而不会发生冲突。 我们使用模板类访问底层数据，根据持久化技术的不同，模板类需要绑定数据连接或会话的资源。但这些资源本身是非线程安全的，也就是说它们不能在同一时刻被多个线程共享。 虽然模板类通过资源池获取数据连接或会话，但资源池本身解决的是数据连接或会话的缓存问题，并非数据连接或会话的线程安全问题。 按照传统经验，如果某个对象是非线程安全的，在多线程环境下，对对象的访问必须采用synchronized进行线程同步。但Spring的DAO模板类并未采用线程同步机制，因为线程同步限制了并发访问，会带来很大的性能损失。 ThreadLocal是什么早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 ThreadLocal很容易让人望文生义，想当然地认为是一个“本地线程”。其实，ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。 当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 线程局部变量并不是Java的新发明，很多语言（如IBM IBM XL FORTRAN）在语法层面就提供线程局部变量。在Java中没有提供在语言级支持，而是变相地通过ThreadLocal的类提供支持。 所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。 ThreadLocal的接口方法 ThreadLocal类接口很简单，只有4个方法，我们先来了解一下： · void set(Object value) 设置当前线程的线程局部变量的值。 · public Object get() 该方法返回当前线程所对应的线程局部变量。 · public void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 · protected Object initialValue() 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。 值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。 ThreadLocal**是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546SimpleThreadLocalpublic class SimpleThreadLocal &#123;private Map valueMap = Collections.synchronizedMap(new HashMap());public void set(Object newValue) &#123; valueMap.put(Thread.currentThread(), newValue); ①**键为线程对象，值为本线程的变量副本**&#125;public Object get() &#123; Thread currentThread = Thread.currentThread(); Object o = valueMap.get(currentThread); ②**返回本线程对应的变量** if (o == null &amp;&amp; !valueMap.containsKey(currentThread)) &#123; ③**如果在Map中不存在，放到Map**中保存起来。 o = initialValue(); valueMap.put(currentThread, o);&#125; return o;&#125;public void remove() &#123; valueMap.remove(Thread.currentThread());&#125;public Object initialValue() &#123; return null;&#125;&#125; 虽然这个ThreadLocal实现版本显得比较幼稚，但它和JDK所提供的ThreadLocal类在实现思路上是相近的。 一个具体的实例了解一下ThreadLocal的具体使用方法。 SequenceNumber 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.baobaotao.basic;public class SequenceNumber &#123;①**通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值**private static ThreadLocal seqNum = new ThreadLocal()&#123;public Integer initialValue()&#123; return 0;&#125;&#125;;②**获取下一个序列值**public int getNextNum()&#123; seqNum.set(seqNum.get()+1); return seqNum.get();&#125;public static void main(String[] args) &#123; SequenceNumber sn = new SequenceNumber(); ③ 3**个线程共享sn，各自产生序列号** TestClient t1 = new TestClient(sn); TestClient t2 = new TestClient(sn); TestClient t3 = new TestClient(sn); t1.start(); t2.start(); t3.start();&#125;private static class TestClient extends Thread&#123;private SequenceNumber sn;public TestClient(SequenceNumber sn) &#123; this.sn = sn;&#125;public void run()&#123; for (int i = 0; i &lt; 3; i++) &#123;④**每个线程打出3个序列值**System.out.println(\"thread[\"+Thread.currentThread().getName()+\"] sn[\"+sn.getNextNum()+\"]\");&#125;&#125;&#125;&#125; 通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个SequenceNumber实例。运行以上代码，在控制台上输出以下的结果： thread[Thread-2] sn[1] thread[Thread-0] sn[1] thread[Thread-1] sn[1] thread[Thread-2] sn[2] thread[Thread-0] sn[2] thread[Thread-1] sn[2] thread[Thread-2] sn[3] thread[Thread-0] sn[3] thread[Thread-1] sn[3] 考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个SequenceNumber实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。 Thread同步机制的比较 ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 当然ThreadLocal并不能替代同步机制，两者面向的问题领域不同。同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式；而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制；如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal，这将极大地简化你的程序，使程序更加易读、简洁。 由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal版本。 概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 Spring使用ThreadLocal解决线程安全问题 我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolderTransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程 这样你就可以根据需要，将一些非线程安全的变量以ThreadLocal存放，在同一次请求响应的调用线程中，所有关联的对象引用到的都是同一个变量。 下面的实例能够体现Spring对有状态Bean的改造思路： 代码清单3 TopicDao：非线程安全 1234567891011public class TopicDao &#123; private Connection conn;①**一个非线程安全的变量** public void addTopic()&#123; Statement stat = conn.createStatement(); ②**引用非线程安全变量** &#125;&#125; 由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造： TopicDao：线程安全 123456789101112131415161718192021222324252627282930313233343536373839import java.sql.Connection;import java.sql.Statement;public class TopicDao &#123;①**使用ThreadLocal保存Connection变量**private static ThreadLocal connThreadLocal = new ThreadLocal();public static Connection getConnection()&#123; ②**如果connThreadLocal没有本线程对应的Connection创建一个新的 Connection，**并将其保存到线程本地变量中。 if (connThreadLocal.get() == null) &#123; Connection conn = ConnectionManager.getConnection(); connThreadLocal.set(conn); return conn;&#125;else&#123; return connThreadLocal.get();③**直接返回线程本地变量**&#125;&#125;public void addTopic() &#123; ④**从ThreadLocal中获取线程对应的Connection** Statement stat = getConnection().createStatement();&#125;&#125; 不同的线程在使用TopicDao时，先判断connThreadLocal.get()是否是null，如果是null，则说明当前线程还没有对应的Connection对象，这时创建一个Connection对象并添加到本地线程变量中；如果不为null，则说明当前的线程已经拥有了Connection对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的Connection，而不会使用其它线程的Connection。因此，这个TopicDao就可以做到singleton共享了。 当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在DAO只能做到本DAO的多个方法共享Connection时不发生线程安全问题，但无法和其它DAO共用同一个Connection，要做到同一事务多DAO共享同一Connection，必须在一个共同的外部类使用ThreadLocal保存Connection。但这个实例基本上说明了Spring对有状态类线程安全化的解决思路。 小结 ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。","tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"JDBC（基础整理）","date":"2016-12-11T07:00:39.000Z","path":"2016/12/11/JDBC/","text":"Java Database Connection:java数据库连接技术。 查看详情 四种连接方式（只写两种）： 1 桥连： JDBC-ODBC连接。 2 直连： 直接通过JDBC驱动连接数据库。 JDBC中的核心接口与类三个核心接口Connection接口：连接数据库接口。负责与数据库之间的连接。 Statement接口：操作数据库接口，常用的子接口PreparedStatement接口，预处理SQL语句。负责执行CRUD命令。 ​ 获得Statement对象 1Statement stat = conn.createStatement(); ​ 执行查询的方法： ResultSet rs = stat.executeQuery(SQL); 执行增删改的方法: ​ int i = stat.executeUpdate(SQL); ResultSet接口：结果集接口。负责接收查询的结果。 结果集对象下移一条时调用方法 next(); ​ 两个值：BOF , EOF ​ BOF：第一行的前面。rs对象一开始指向的位置就是BOF。 ​ EOF：最后一行的后面。rs对象的next方法是下移一行，如果移动之 后指向了EOF返回false，表示没有记录 12345678910111213141516171819202122232425262728293031323334import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;import java.util.Date;public class Test &#123; public static void main(String[] args) throws Exception &#123; //连接数据库的四大参数项 String username = \"scott\"; String password = \"tiger\"; String driver_class=\"oracle.jdbc.driver.OracleDriver\";//驱动类名称 String url = \"jdbc:oracle:thin:@localhost:1521:XE\";//连接字符串// 1、加载JDBC的驱动-连接哪个数据库产品就加载哪个数据库的JDBC驱动 Class.forName(driver_class);// 2、创建与数据库之间的连接 Connection conn = DriverManager.getConnection(url, username , password);// 3、执行CRUD命令 String sql = \"select * from emp\"; Statement stat = conn.createStatement();// 4、如果是查询就处理结果集 ResultSet rs = stat.executeQuery(sql); //rs是结果集对象，结果集就是一个二维表格。 while(rs.next())&#123;//下一行。如果返回true说明有记录。 int empno = rs.getInt(1); String ename = rs.getString(\"ename\"); Date date = rs.getDate(\"hiredate\"); System.out.println(empno+\":\"+ename+\":\"+date); &#125;// 5、关闭连接，释放资源 rs.close(); stat.close(); conn.close(); &#125;&#125; 对数据库进行增删改操作 12345678910111213141516171819202122232425262728293031import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.Statement;import java.util.Date;public class UpdateTest &#123; public static void main(String[] args) throws Exception &#123; //连接数据库的四大参数项 String username = \"scott\"; String password = \"tiger\"; String driver_class=\"oracle.jdbc.driver.OracleDriver\";//驱动类名称 String url = \"jdbc:oracle:thin:@localhost:1521:XE\";//连接字符串// 1、加载JDBC的驱动-连接哪个数据库产品就加载哪个数据库的JDBC驱动 Class.forName(driver_class);// 2、创建与数据库之间的连接 Connection conn = DriverManager.getConnection(url, username , password); System.out.println(conn);// 3、执行CRUD命令 String sql = \"insert into dept(deptno,dname,loc) values(50 , '总部' ,'北京远洋')\"; Statement stat = conn.createStatement(); int count = stat.executeUpdate(sql);//增删改都调用这个方法 if(count &gt; 0) &#123; System.out.println(\"操作成功！\"); &#125;// 7.5、关闭连接，释放资源 stat.close(); conn.close(); &#125;&#125; PreparedStatement接口：Statement子接口，预处理SQL语句。 创建PreparedStatement接口的实例String sql = “insert into dept(deptno,dname,loc) values(?,?,?)”;//可以使用?占位符 PreparedStatementpstat = conn.prepareStatement(sql); //为占位符赋值 pstat.setInt(1, deptno); pstat.setString(2, dname); pstat.setString(3, loc); 执行 pstat.executeUpdate(); 数据库连接池技术世面上主流有:DBCP , C3P0使用DBCP创建数据库连接对象设置DBCP连接池参数 创建一个资源文件.properteis。 12345678910111213driverClassName=oracle.jdbc.driver.OracleDriver url=jdbc:oracle:thin:@localhost:1521:XE username=scott password=tiger maxActive=50--最大活动数量 maxIdle=20 --最大空闲数量 maxWait=60000 --最大等待时间，毫秒。 ##","tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"","date":"2016-12-11T06:46:31.534Z","path":"2016/12/11/java-Throwable/","text":"","tags":[]},{"title":"java collection接口（基础整理）","date":"2016-12-11T02:49:39.000Z","path":"2016/12/11/java-API/","text":"集合的整体的框架结构转自 http://blog.csdn.net/softwave/article/details/4166598 在整个集合框架中顶层的接口：Collection接口。 在Collection接口下有两个子接口List 和Set 在整个集合框架中还有一个接口Map Collection├List│├LinkedList│├ArrayList│└Vector│ └Stack└SetMap├Hashtable├HashMap└WeakHashMap Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements） 所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个 Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后 一个构造函数允许用户复制一个Collection。 如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下： Iterator it = collection.iterator(); // 获得一个迭代子 while(it.hasNext()) { Object obj = it.next(); // 得到下一个元素 } 由Collection接口派生的两个接口是List和Set。 List接口 List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。 除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素， 还能向前或向后遍历。 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。 LinkedList类 LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。 注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(…)); ArrayList类 ​ ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。 size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。 每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法 并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 Vector类 ​ Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和 ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了 Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。 Stack 类 Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Set接口 Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。 很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。 请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。 hashset类HashSet 的实现其实非常简单，它只是封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。 Map接口 Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。 Hashtable类Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。 添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。 使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”： Hashtable numbers = new Hashtable(); numbers.put(“one”, new Integer(1)); numbers.put(“two”, new Integer(2)); numbers.put(“three”, new Integer(3)); 要取出一个数，比如2，用相应的key： Integer n = (Integer)numbers.get(“two”); 由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方 法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相 同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如 果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希 表的操作。 如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。 Hashtable是同步的。 HashMap类 hashmap源码详细讲解http://www.cnblogs.com/ITtangtang/p/3948406.html HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例 总结 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。 要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。 尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。 相互区别Vector和ArrayList 1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用 arraylist效率比较高。2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度 的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而 如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据 所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。 ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动 等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要 差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！ arraylist和linkedlist 1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数 据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 HashMap与TreeMap (注) 文章出处：http://www.diybl.com/course/3_program/java/javaxl/200875/130233.html 1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。 2, 、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。 hashtable与hashmap 一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 三.值：只有HashMap可以让你将空值作为一个表的条目的key或value","tags":[{"name":"API","slug":"API","permalink":"http://yoursite.com/tags/API/"}]},{"title":"java oop（基础整理）","date":"2016-12-11T01:58:25.000Z","path":"2016/12/11/java-oop/","text":"JavaBean规范1 类一定要有默认构造方法。 2 属性要private。 3 通过public的方法来操作属性。 final修饰符可以修饰三个对象 1 变量：局部变量，常量，值不可改变。 类中的属性： 1 属性可以初始化，但不能通过set方法赋值。 2 属性的初始化一定要使用类的构造方法，所以默认构造方法不可 用。 基本数据类型：值不可改变。 引用数据类型：引用不可改变。 2方法：方法不可改变。方法不能被重写。 3类：类不可改变。类不能被继承。 static修饰符叫静态修饰符。 1 代码块：静态代码块，静态块。 代码块：{ } 静态代码块：static{ } 给静态属性初始化用的。 2 属性：静态属性 没加的static的属性叫实例属性。是实例的。 加了static叫静态属性，也叫类属性。是类的。 静态方法只可以访问静态属性和静态方法。 abstract修饰符Abstract中文叫抽象。 可以修饰二个地方：方法和类。 6.1 抽象方法：使用abstract修饰符修饰的方法。 抽象方法有自己的固定格式：没有方法体。 抽象类：类前面加abstract修饰符的类,叫抽象类。 一个类中如果有抽象方法，这个类必须是抽象类。 在一个抽象类中可以有属性，方法，抽象方法，但也可不存在抽象方法。 抽象类不能被实例化。 抽象类在使用时一定要做为父类，让子类继承，重写抽象方法。 接口（interface）1 公有静态常量，publicstatic final 2 公有抽象方法，抽象方法的修饰符abstract。但是在接口中只能有抽象方法，在接口可以省略abstract 使用1 不能被new，实例化。 2 一定要找一个类，去实现接口。关键字implements 在实现类中一定要对接口中声明的抽象方法给出具体的实现。重写接口中的抽象方法。 4 当实现类中不能将接口中所有的抽象方法全部给出实现时，这个实现类就必须是抽象类。 5 接口同样支持面向对象的多态这个特性。 接口类型的引用可以指向一个其实现类的实例。 接口类型 接口类型引用 = new 实现类（）; 6 一个类只能继承自一个父类。Extends 类 只能有一个。Java是一种单继承的语言。 7 一个类可以实现多个接口。Implements 接口1，接口2 8 一个类可以同时继承一个父类，再同时实现多个接口。 this关键字在实例内部代表实例本身的一个引用。一般在参数名称与属性名称一致时，用来区分哪个是属性用的。在属性前面加上”this.” this关键字在实例内部可以调用三个内容： 1属性：调用实例本身自己的属性。 this.属性名 2方法：调用实例本身自己的方法。 this.方法名（）; 3构造方法：调用实例本身自己的构造方法。 this(); 只能写在构造方法中。 只能写在构造方法的第一行 构造方法构造方法是一个特殊的方法。 1 方法名称必须与类名一致。完全一致。大小写都要一致。 2 方法没有返回类型说明。注意不是没有返回值，是没有返回类型的说明。 构造方法是在new时（实例化），由系统自动调用的方法。（在实例化一个类的对象的过程中一同类同名不同参： 在一个类中有多个同名的方法，但是方法的参数不同时，把这几个同名的方法叫方法重载。 参数不同包含： 1参数个数。 2参数类型。 构造方法也是方法，所以构造方法也可以重载。定要调用构造方法） 构造方法的作用是用来构造实例并初始化属性。 方法重载 同类同名不同参： 在一个类中有多个同名的方法，但是方法的参数不同时，把这几个同名的方法叫方法重载。 参数不同包含 ​ 1参数个数。 2参数类型。 构造方法也是方法，所以构造方法也可以重载。 面向对象的三大特性-封装，继承，多态封装的目的是为了实现模块化开发。 具体体现方式：封装的目的是为了获得类和方法。 访问修饰符private : 私有，只能类内使用。子类不能访问。 （default）：默认，包级别，本类和同包可用。 protected：保护，同包和子类。 public ： 公有，任何位置都可以访问 继承的特点子类可以复用父类中的属性和方法。（必须参考访问修饰符，如果属性或方法是以private修饰时，在子类中不能使用父类的方法了。）继承不是单纯的代码复制。会为这个子类在创建子类实例时同时也创建一个属于这个子类实例的父类实例。 Java会为每个子类实例都关联一个父类实例。 方法重写(Override)两个类要有继承关系。 在子类重新编写相同的方法。方法名称，返回类型，参数都必须相同。 我们就叫方法重写 super关键字在实例内部引用其父类实例的一个引用。使用super关键字可以调用父类的属性和方法。 关于super常见的用法 1super.父类方法（）; 调用父类的方法。一般在子类重写的方法中调用父类的方法。 ​ 2 super（）; 调用父类的构造方法。只能在子类的构造方法的第一行出现。用来明确指定调用父类的哪个构造方法。 在没有多态时，使用继承的目的是为了代码复用。 在没有多态时，使用继承的目的是为了修改现有类，创建新类。 多态（是面向对象语言的最核心的特性）多态的基础： 1 要有继承：extends 2要有方法重写：在子类中重写父类继承的方法。声明一个与父类一样的方法。但是方法的内容可以重新写。 多态的格式：父类引用指向子类实例 父类类型 父类引用 = new 子类类型(); ​ 父类引用指向了一个子类的实例时，父类引用可以调用二类方法。 1父类中声明的自己的方法。 2 子类中重写父类的方法。 多态的一般使用方法的格式：1将父类引用做为方法的形参。 2将子类实例做为方法的实参。","tags":[{"name":"javaoop","slug":"javaoop","permalink":"http://yoursite.com/tags/javaoop/"}]},{"title":"java基础整理","date":"2016-12-11T01:31:16.000Z","path":"2016/12/11/java1/","text":"垃圾回收JAVA程序运行过程中，有一个线程叫垃圾回收线程。程序运行了一时间之后很多垃圾信息。回收。 自动调用。程序员不能控制。1 内存不够。2 CPU空闲。 垃圾：没有被引用的内存空间。 java运行机制Java先编译后解释型语言。 源文件(.java)----编译-&gt;类文件(.class)（字节码文件）---解释执行（JVM：java虚拟机）---&gt;机器指令 JDK(Java Development Kit) Java开发工具包 JDK = JRE + 工具（编译器、调试器、其他工具……） + 类库 JRE (Java Runtime Environment) Java运行时环境 JRE = JVM(Java Virtual Machine) Java虚拟机+解释器 原始数据类型就只有8个：byte,short,int,long float,double char boolean String字符串数据类型String实际上它是一个类, 字符串不变性：表示字符串字面量是不会改变的。 字符串常量池。用来存放字符串常量 数组数组就是保存同一类型的一大堆的变量。 声明一个数组。 int[] a; 推荐使用。 数组的异常- ArrayIndexOutOfBoundsException（索引超出范围） 数组是引用数据类型 当一个数组给另一个数组，使用数组名称赋值时，实际上是将数组的引用交给另一个数组。 两个数组使用的是同一块内存，两个数组引用是相同的。 所以一个数组对数组元素的修改等于两个数组一起改变。 java.util.Arrays类。封装了针对数组的操作方法。 sort。排序方法。sort(byte[] a)对指定的 byte 型数组按数字升序进行排序。 binarySearch(int[]a,int key) 使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。 参数： a - 要搜索的数组 key - 要搜索的值 返回： 如果它包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。*插入点* 被定义为将键插入数组的那一点：即第一个大于此键的元素索引，如果数组中的所有元素都小于指定的键，则为 a.length。注意，这保证了当且仅当此键被找到时，返回的值将 &gt;= 0。 copyOf使用老数组创建一个新的数组。同时拷贝数据。 二维数组和多维数组二维数组是否可以排序？不能，会报ClassCastException异常。 函数为什么要创建函数？ 一个函数代表了一个功能。功能最好单一，独立，不可拆分。 可以重复使用 调用方便 结构清晰，层次更明确，修改容易。 可以利用函数将多层的循环变成多个一层的循环。 为了给我们的程序分模块。 “","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"multithreading","date":"2016-12-10T14:50:56.000Z","path":"2016/12/10/multithreading/","text":"多线程参考进程和线程区别 1.定义进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 2.关系 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 3.区别 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 4.优缺点 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 http://blog.csdn.net/ITMagic_Jack/article/details/6196939 二：在Java中实现多线程继承 Thread 类，覆盖方法 run()： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[java] view plain copy1. public class FishMeThread extends Thread &#123; 2. 3. int count= 1, number; 4. 5. public FishMeThread(int num) &#123; 6. number = num; 7. System.out.println(\"创建线程 \" + number); 8. &#125; 9. 10. public void run() &#123; 11. while(true) &#123; 12. System.out.println(\"线程 \" + number + \":计数 \" + count); 13. if(++count== 6) return; 14. &#125; 15. &#125; 16. 17. public static void main(String args[]) &#123; 18. for(int i = 0; i &lt; 5; i++) &#123; 19. new FishMeThread(i + 1).start(); 20. &#125; 21. &#125; 22. 23. &#125; 方法二：实现 Runnable 接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[java] view plain copy1. public class FishMeThread implements Runnable &#123; 2. 3. int count= 1, number; 4. 5. public MyThread(int num) &#123; 6. number = num; 7. System.out.println(\"创建线程 \" + number); 8. &#125; 9. 10. public void run() &#123; 11. while(true) &#123; 12. System.out.println(\"线程 \" + number + \":计数 \" + count); 13. if(++count== 6) return; 14. &#125; 15. &#125; 16. 17. public static void main(String args[]) &#123; 18. for(int i = 0; i &lt; 5; i++) &#123; 19. new Thread(new MyThread(i+1)).start(); 20. &#125; 21. &#125; 22. 23. &#125; 将我们希望线程执行的代码放到run方法中，然后通过start方法来启动线程，start方法首先为线程的执行准备好系统资源，然后再去调用run方法。当某个类继承了Thread类之后，该类就叫做一个线程类。 三、Thread源码研究：1) Thread类也实现了Runnable接口，因此实现了Runnable接口中的run方法；2) 当生成一个线程对象时，如果没有为其设定名字，那么线程对象的名字将使用如下形式：Thread-number,该number将是自动增加的，并被所有的Thread对象所共享（因为它是static的成员变量）。3) 当使用第一种方式来生成线程对象时，我们需要重写run方法，因为Thread类的run方法此时什么事情也不做。4）当使用第二种方式生成线程对象时，我们需要实现Runnable接口的run方法，然后使用new Thread（new MyThread（））（假如MyThread已经实现了Runnable接口）来生成线程对象，这时的线程对象的run方法或调就会MyThread类的run方法，这样我们自己编写的run方法就执行了。当使用继承Thread生成线程对象时，target为空，什么也不执行，当使用第二种方式生成时，执行target.run（），target为runnable的实例对象，即为执行重写后的方法总结：两种生成线程对象的区别：1.两种方法均需执行线程的start方法为线程分配必须的系统资源、调度线程运行并执行线程的run方法。2.在具体应用中，采用哪种方法来构造线程体要视情况而定。通常，当一个线程已继承了另一个类时，就应该用第二种方法来构造，即实现Runnable接口。 三：线程的四种状态 新状态：线程已被创建但尚未执行（start() 尚未被调用）。 可执行状态：线程可以执行，虽然不一定正在执行。CPU 时间随时可能被分配给该线程，从而使得它执行。 死亡状态：正常情况下 run() 返回使得线程死亡。调用 stop()或 destroy() 亦有同样效果，但是不被推荐，前者会产生异常，后者是强制终止，不会释放锁。 阻塞状态：线程不会被分配 CPU 时间，无法执行。 四：线程的优先级线程的优先级代表该线程的重要程度，当有多个线程同时处于可执行状态并等待获得 CPU 时间时，线程调度系统根据各个线程的优先级来决定给谁分配 CPU 时间，优先级高的线程有更大的机会获得 CPU 时间，优先级低的线程也不是没有机会，只是机会要小一些罢了。你可以调用 Thread 类的方法 getPriority() 和 setPriority()来存取线程的优先级，线程的优先级界于1(MIN_PRIORITY)和10(MAX_PRIORITY)之间，缺省是5(NORM_PRIORITY)。 五：线程的同步http://www.2cto.com/kf/201408/324061.html由于同一进程的多个线程共享同一片存储空间，在带来方便的同时，也带来了访问冲突这个严重的问题。Java语言提供了专门机制以解决这种冲突，有效避免了同一个数据对象被多个线程同时访问。由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需针对方法提出一套机制，这套机制就是 synchronized 关键字，它包括两种用法：synchronized 方法和 synchronized 块。 synchronized 方法：通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。如： public synchronized void accessVal(int newVal);synchronized 方法控制对类成员变量的访问：每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态（因为至多只有一个能够获得该类实例对应的锁），从而有效避免了类成员变量的访问冲突（只要所有可能访问类成员变量的方法均被声明为 synchronized）。在 Java 中，不光是类实例，每一个类也对应一把锁，这样我们也可将类的静态成员函数声明为 synchronized ，以控制其对类的静态成员变量的访问。synchronized 方法的缺陷：若将一个大的方法声明为synchronized将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。当然我们可以通过将访问类成员变量的代码放到专门的方法中，将其声明为 synchronized ，并在主方法中调用来解决这一问题，但是 Java 为我们提供了更好的解决办法，那就是 synchronized 块。 synchronized 块：通过 synchronized关键字来声明synchronized 块。语法如下： synchronized(syncObject) { //允许访问控制的代码}synchronized 块是这样一个代码块，其中的代码必须获得对象 syncObject （如前所述，可以是类实例或类）的锁方能执行，具体机制同前所述。由于可以针对任意代码块，且可任意指定上锁的对象，故灵活性较高。 ​ 3.使用特殊域变量(volatile)实现线程同步 a.volatile关键字为域变量的访问提供了一种免锁机制， b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。 用final域，有锁保护的域和volatile域可以避免非同步的问题。 4.使用重入锁实现线程同步 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。 ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力 ReenreantLock类的常用方法有： ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 注：关于Lock对象和synchronized关键字的选择： a.最好两个都不用，使用一种java.util.concurrent包提供的机制， 能够帮助用户处理所有与锁相关的代码。 b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码 c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 5.使用局部变量实现线程同步 如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。 ThreadLocal 类的常用方法 ThreadLocal() : 创建一个线程本地变量 get() : 返回此线程局部变量的当前线程副本中的值 initialValue() : 返回此线程局部变量的当前线程的”初始值” set(T value) : 将此线程局部变量的当前线程副本中的值设置为value ThreadLocal与同步机制a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。 b.前者采用以&quot;空间换时间&quot;的方法，后者采用以&quot;时间换空间&quot;的方式 六：线程的阻塞为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持。阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。 suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程。 wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。 初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。关于 wait() 和 notify() 方法最后再说明两点：第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。 生产者消费者模型 http://blog.csdn.net/zhangyuan19880606/article/details/51153035 一种重要的模型，基于等待/通知机制。生产者/消费者模型描述的是有一块缓冲区作为仓库，生产者可将产品放入仓库，消费者可以从仓库中取出产品，生产者/消费者模型关注的是以下几个点： 1、生产者生产的时候消费者不能消费 2、消费者消费的时候生产者不能生产 3、缓冲区空时消费者不能消费 4、缓冲区满时生产者不能生产 生产者/模型作为一种重要的模型，它的优点在于： 1、解耦。因为多了一个缓冲区，所以生产者和消费者并不直接相互调用，这一点很容易想到，这样生产者和消费者的代码发生变化，都不会对对方产生影响，这样其实就把生产者和消费者之间的强耦合解开，变为了生产者和缓冲区/消费者和缓冲区之间的弱耦合 1234567891011121314151617181920212223242526272829303132333435363738** * 公共资源类 */ public class PublicResource &#123; private int number = 0; /** * 增加公共资源 */ public synchronized void increace() &#123; while (number != 0) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; number++; System.out.println(number); notify(); &#125; /** * 减少公共资源 */ public synchronized void decreace() &#123; while (number == 0) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; number--; System.out.println(number); notify(); &#125; &#125; 二，分别定义生产者线程和消费者线程，并模拟多次生产和消费，即增加和减少公共资源的number值 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 生产者线程，负责生产公共资源 */ public class ProducerThread implements Runnable &#123; private PublicResource resource; public ProducerThread(PublicResource resource) &#123; this.resource = resource; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; resource.increace(); &#125; &#125; &#125; /** * 消费者线程，负责消费公共资源 */ public class ConsumerThread implements Runnable &#123; private PublicResource resource; public ConsumerThread(PublicResource resource) &#123; this.resource = resource; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; resource.decreace(); &#125; &#125; &#125; 三，模拟多个生产者和消费者操作公共资源的情形，结果须保证是在允许的范围内。 12345678910public class ProducerConsumerTest &#123; public static void main(String[] args) &#123; PublicResource resource = new PublicResource(); new Thread(new ProducerThread(resource)).start(); new Thread(new ConsumerThread(resource)).start(); new Thread(new ProducerThread(resource)).start(); new Thread(new ConsumerThread(resource)).start(); new Thread(new ProducerThread(resource)).start(); new Thread(new ConsumerThread(resource)).start(); &#125; 生产数据和消费数据一定是成对出现的，生产一个消费一个，满了不生产，空了不消费，生产者不能无限生产，消费者也不能无限消费，符合生产者/消费者模型。生产者速度快，就不占用CPU时间片，等着消费者消费完通知它继续生产，这块时间片可以用来给其他线程用。 七：守护线程守护线程是一类特殊的线程，它和普通线程的区别在于它并不是应用程序的核心部分，当一个应用程序的所有非守护线程终止运行时，即使仍然有守护线程在运行，应用程序也将终止，反之，只要有一个非守护线程在运行，应用程序就不会终止。守护线程一般被用于在后台为其它线程提供服务。 可以通过调用方法 isDaemon() 来判断一个线程是否是守护线程，也可以调用方法 setDaemon() 来将一个线程设为守护线程。 死锁：产生死锁的四个必要条件： （1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 锁的类别有两种分法： 从数据库系统的角度来看：分为独占锁（即排它锁），共享锁和更新锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758591. &lt;span style=\"font-size:18px;\"&gt;class Test implements Runnable 2. &#123; 3. private boolean flag; //flag标签，让t1和t2线程执行不同代码 4. public Test(boolean flag) 5. &#123; 6. this.flag=flag; 7. &#125; 8. public void run() 9. &#123; 10. if (flag) 11. &#123; 12. synchronized(MyLock.lock1) 13. &#123; 14. System.out.println(\"if1\"); 15. 16. synchronized(MyLock.lock2) 17. &#123; 18. System.out.println(\"if2\"); 19. &#125; 20. &#125; 21. &#125; 22. else 23. &#123; 24. synchronized(MyLock.lock2) 25. &#123; 26. System.out.println(\"else2\"); 27. 28. synchronized(MyLock.lock1) 29. &#123; 30. System.out.println(\"else1\"); 31. &#125; 32. &#125; 33. &#125; 34. 35. &#125; 36. 37. 38. &#125; 39. 40. class MyLock //两个锁，用来制造死锁 41. &#123; 42. public static Object lock1 = new Object(); 43. public static Object lock2 = new Object(); 44. 45. &#125; 46. 47. class DeadLock 48. &#123; 49. public static void main(String[] args) 50. &#123; 51. Thread t1 = new Thread(new Test(true)); //t1先用锁1再用锁2 52. Thread t2 = new Thread(new Test(false));//t2先用锁2再用锁1 53. 54. t1.start(); 55. t2.start(); 56. 57. &#125; 58. &#125; 59. &lt;/span&gt;","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"first","date":"2016-12-10T11:22:57.000Z","path":"2016/12/10/first/","text":"","tags":[{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"}]}]